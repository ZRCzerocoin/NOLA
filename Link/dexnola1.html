<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NOLA Exchange â€” Full (Enhanced)</title>
<style>
/* ===== RESET & THEME ===== */
*{margin:0;padding:0;box-sizing:border-box;font-family:'Arial',sans-serif}
html,body{height:100%}
body{
  /* Disable page scrolling by default â€” suggestions & chat keep their own scroll */
  overflow:hidden;
  background:radial-gradient(circle at center,#0c0014,#1a002b 80%);
  color:#fff;scroll-behavior:smooth;min-height:100vh;
}
:root{
  --accent-1:#b445ff;--accent-2:#7013ff;
  --glass:rgba(255,255,255,0.05);--glass-2:rgba(255,255,255,0.03);
  --suggest-bg:rgba(25,0,50,0.98);
  --shadow:0 0 25px rgba(180,0,255,0.3);
  --container-max:520px;
  --glass-btn-bg:rgba(255,255,255,0.03);
  --glass-btn-border:rgba(255,255,255,0.06);
  --yellow-cta:#ffcf33;
  --toast-info-grad: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
  --disabled-glass: rgba(255,255,255,0.02);
  --focus-ring: 0 0 0 4px rgba(180,68,255,0.08);
}

/* NEBULA + PARTICLES */
body::before{content:'';position:fixed;left:-50%;top:-50%;width:200%;height:200%;background:radial-gradient(circle,rgba(150,0,255,0.12),transparent 60%);animation:nebulaMove 20s infinite alternate ease-in-out;z-index:-2}
@keyframes nebulaMove{0%{transform:translate(-10%,-10%)}100%{transform:translate(5%,5%)}}
.particle{position:absolute;width:2px;height:2px;background:#b445ff;border-radius:50%;opacity:0.8;animation:floatParticle linear infinite;z-index:-1}
@keyframes floatParticle{0%{transform:translateY(0) translateX(0);opacity:0.8}50%{transform:translateY(-50px) translateX(20px);opacity:0.4}100%{transform:translateY(0) translateX(0);opacity:0.8}}

/* TOP LOGO moved down to sit above section */
.logo{
  width:84px;height:auto;display:block;margin:0 auto;pointer-events:none;
  animation:logoGlow 15s ease-in-out infinite alternate,logoRotate 45s linear infinite;
  z-index:998;position:fixed;left:50%;top:8vh;transform:translateX(-50%);
}
@keyframes logoGlow{0%{filter:drop-shadow(0 0 12px #9c00ff)}50%{filter:drop-shadow(0 0 30px #d15fff)}100%{filter:drop-shadow(0 0 12px #9c00ff)}}
@keyframes logoRotate{0%{transform:translateX(-50%) rotateY(0deg)}100%{transform:translateX(-50%) rotateY(360deg)}}

/* SECTION WRAPPER - CENTER EVERYTHING */
.section-wrapper{min-height:100vh;display:flex;align-items:center;justify-content:center;gap:18px;padding:28px;position:relative;z-index:1}

/* CARD */
.container{width:90%;max-width:var(--container-max);margin:0;background:var(--glass);border:1px solid rgba(255,255,255,0.08);border-radius:25px;padding:22px;backdrop-filter:blur(18px);box-shadow:var(--shadow);animation:cardIn 800ms ease;position:relative}
@keyframes cardIn{from{opacity:0;transform:translateY(18px)}to{opacity:1;transform:translateY(0)}}
h2{text-align:center;font-size:26px;font-weight:600;margin-bottom:14px;color:#e0b3ff;text-shadow:0 0 8px #b445ff}

/* UNIFIED ROW - compact "thin bar" look */
.input-box{margin-top:14px;padding:8px 10px;background:rgba(255,255,255,0.03);border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;gap:10px;position:relative;box-shadow:0 6px 16px rgba(150,0,255,0.04)}
.input-box .left{display:flex;align-items:center;gap:8px;min-width:0;flex:1}

/* chosen tokens: professional rounded-rectangle icons (not circular) */
.token-icon{width:36px;height:36px;border-radius:8px;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;position:relative;border:1px solid rgba(255,255,255,0.05);z-index:5}
.token-icon img{width:100%;height:100%;object-fit:cover;display:block;border-radius:8px;z-index:6}
.token-chip{position:absolute;right:-8px;bottom:-8px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));padding:3px 7px;border-radius:999px;font-weight:800;font-size:10px;color:#fff;box-shadow:0 8px 22px rgba(180,68,255,0.12),inset 0 -3px 8px rgba(0,0,0,0.12);display:none;white-space:nowrap;transform:translate(6px,6px);z-index:7}
.input-box.has-token .token-chip{display:inline-flex}

/* token info (symbol + 24h change) - placed neatly next to icon */
.token-symbol{display:none}
.token-change{font-size:12px;opacity:0.95}

/* SUGGESTIONS container (internal scroll only) */
.suggestions{position:absolute;top:68px;left:12px;right:12px;background:var(--suggest-bg);border-radius:12px;padding:6px;max-height:240px;overflow:auto;display:none;z-index:220;box-shadow:0 10px 30px rgba(120,0,255,0.08)}
.suggestion-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:10px;cursor:pointer;justify-content:space-between}
.suggestion-item:hover{background:linear-gradient(90deg, rgba(180,68,255,0.06), rgba(112,19,255,0.04))}
.suggestion-left{display:flex;align-items:center;gap:10px;min-width:0}
.suggestion-left img{width:28px;height:28px;border-radius:50%;object-fit:cover}
.suggestion-main{display:flex;flex-direction:column;min-width:0}
.suggestion-symbol{font-weight:700;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.suggestion-name{font-size:12px;opacity:0.8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.suggestion-price-pill{min-width:70px;text-align:right;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);font-weight:700;font-size:12px}

/* INPUT BLOCK (single visible text input per row) */
.input-field{display:flex;flex-direction:column;min-width:0;width:100%}
.input-field input[type="text"]{padding:8px 10px;border-radius:8px;border:none;background:transparent;color:#fff;width:100%;outline:none;font-size:14px}
.input-amount{margin-left:8px;min-width:120px}
.input-amount input{width:100%;padding:8px 10px;border-radius:8px;border:none;background:rgba(255,255,255,0.03);color:#fff;font-size:14px;outline:none}

/* small price area under amount/estimate - align to right without covering icons */
.price-small{display:flex;flex-direction:column;align-items:flex-end;margin-left:auto;margin-top:6px;min-width:120px;z-index:2}
.price-small .price-usd{font-size:12px;opacity:0.85}
.price-small .price-unit{font-size:12px;opacity:0.65}

/* SWAP CONTROLS */
.controls{margin-top:14px;display:flex;align-items:center;gap:12px;justify-content:space-between}
.swap-outside{
  width:46px;height:46px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);box-shadow:0 8px 20px rgba(120,0,255,0.06);cursor:pointer;font-size:20px;color:#fff;transition:transform 120ms ease;backdrop-filter:blur(6px)}
.swap-outside:active{transform:translateY(1px);box-shadow:none}

/* custom slippage dropdown */
.slippage-wrap{position:relative;display:inline-block}
.slippage-display{
  padding:8px 12px;border-radius:10px;background:var(--glass);color:#fff;border:0;font-weight:800;font-size:13px;box-shadow:0 8px 22px rgba(106,0,255,0.12);cursor:pointer;display:flex;align-items:center;gap:8px;
}
.slippage-list{position:absolute;right:0;top:calc(100% + 8px);background:var(--glass);border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:6px;box-shadow:var(--shadow);min-width:120px;display:none;z-index:400}
.slippage-item{padding:8px 10px;border-radius:8px;cursor:pointer;font-weight:700;white-space:nowrap}
.slippage-item:hover{background:linear-gradient(90deg, rgba(180,68,255,0.06), rgba(112,19,255,0.04))}

/* GLASSY BUTTON (replaces electric pill) */
.glassy-btn{
  display:inline-flex; align-items:center; gap:10px; padding:10px 20px; border-radius:12px;
  background:var(--glass-btn-bg); border:1px solid var(--glass-btn-border);
  color:#fff; font-weight:800; font-size:15px; cursor:pointer;
  transition:transform 120ms ease,box-shadow 120ms ease,background 120ms ease; backdrop-filter: blur(6px);
}
.glassy-btn:active{transform:translateY(1px);box-shadow:none}
.glassy-btn[disabled]{opacity:0.45;cursor:not-allowed;box-shadow:none;border:1px solid rgba(255,255,255,0.02);background:var(--disabled-glass)}
.glassy-btn.connected{background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#fff;}

/* center main swap button */
.swap-row{margin-top:14px;display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap}

/* yellow quick-swap CTA */
.quick-cta{
  background: linear-gradient(90deg,var(--yellow-cta),#f7b400);
  color:#1b1b1b; padding:10px 16px; border-radius:12px; border:none; font-weight:900; cursor:pointer;
  display:inline-flex; gap:8px; align-items:center;
  box-shadow: 0 10px 30px rgba(255,200,50,0.12);
}
.quick-cta:active{transform:translateY(1px);box-shadow:none}
.quick-cta[disabled]{opacity:0.5;cursor:not-allowed}

/* tiny glassy tooltip / toast */
.toast{position:fixed;right:18px;bottom:90px;z-index:9999;padding:12px 18px;border-radius:12px;background:var(--toast-info-grad);backdrop-filter:blur(8px);box-shadow:0 10px 40px rgba(0,0,0,0.5);color:#fff;font-weight:700;max-width:360px}
.toast a{color:#fff;font-weight:900;text-decoration:underline}

/* TOP-RIGHT CONNECT */
.top-right-connect{position:fixed;right:18px;top:18px;z-index:70;display:flex;gap:10px;align-items:center}
.addr-chip{padding:8px 12px;border-radius:12px;background:rgba(255,255,255,0.03);font-weight:700;display:none}
.connect-floating{background:linear-gradient(90deg,var(--glass-btn-bg),var(--glass-btn-bg));color:#fff;padding:10px 14px;border-radius:12px;border:1px solid var(--glass-btn-border);cursor:pointer;font-weight:800;box-shadow:0 10px 30px rgba(106,0,255,0.06);display:flex;align-items:center;gap:8px}

/* footer */
.footer{position:fixed;left:0;right:0;bottom:12px;display:flex;flex-direction:column;gap:6px;align-items:center;justify-content:center;z-index:40;color:rgba(255,255,255,0.75);font-size:13px}
.footer a{color:rgba(215,165,255,0.95);text-decoration:none;font-weight:700;margin-left:8px}

/* small screen polish */
@media(max-width:720px){
  .section-wrapper{padding:18px;gap:12px;flex-direction:column-reverse}
  .container{width:100%;max-width:520px}
  .input-box .token-chip{font-size:10px;padding:3px 6px;right:-4px;bottom:-4px}
  .logo{top:6vh;width:72px}
}

/* CHAT TOGGLE BUTTON */
.chat-toggle {
  position: fixed;
  right: 20px;
  bottom: 20px;
  background: #7A4988;
  padding: 10px 14px;
  border-radius: 20px;
  cursor: pointer;
  box-shadow: 0 0 15px rgba(180, 0, 255, 0.35);
  z-index: 2000;
  transition: 0.3s ease;
}

/* SLIDING CHAT PANEL */
.chat-sidebar {
  position: fixed;
  right: -350px; /* hidden initially */
  top: 20%;
  width: 320px;
  height: 60%;
  background: rgba(0, 0, 0, 0.35);
  backdrop-filter: blur(14px);
  border-radius: 20px 0 0 20px;
  padding: 15px;
  box-shadow: 0 0 25px rgba(0,0,0,0.4);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  transition: right 0.35s ease;
  z-index: 1999;
}

/* OPEN STATE */
.chat-sidebar.open {
  right: 20px;
}

/* MESSAGE BUBBLES */
.chat-msg {
  margin-bottom: 12px;
  padding: 8px 10px;
  border-radius: 12px;
  background: rgba(255,255,255,0.04);
  font-size: 14px;
  word-break: break-word;
}

/* INPUT AREA */
.chat-input {
  display: flex;
  margin-top: auto;
}

.chat-input input {
  flex: 1;
  padding: 8px 10px;
  border-radius: 12px;
  border: none;
  background: rgba(255,255,255,0.05);
  color: white;
}

.chat-input button {
  margin-left: 6px;
  padding: 8px 12px;
  border-radius: 12px;
  border: none;
  background: #7A4988;
  color: white;
  cursor: pointer;
}

/* USERNAME MODAL */
#usernameModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  backdrop-filter: blur(10px);
  background: rgba(0,0,0,0.6);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 3000;
}

#usernameModal .modal-content {
  background: rgba(255,255,255,0.07);
  padding: 25px;
  border-radius: 20px;
  text-align: center;
  width: 300px;
}

#usernameModal input {
  width: 85%;
  padding: 10px;
  border-radius: 12px;
  border: none;
  margin-top: 12px;
  background: rgba(255,255,255,0.06);
  color: white;
}

#usernameModal button {
  margin-top: 15px;
  padding: 10px 20px;
  border-radius: 12px;
  border: none;
  background: linear-gradient(135deg,#b445ff,#7013ff);
  cursor: pointer;
  color: white;
}

/* spinner */
.btn-spinner{width:16px;height:16px;border-radius:50%;border:2px solid rgba(255,255,255,0.2);border-top-color:rgba(255,255,255,1);animation:spin 700ms linear infinite;display:inline-block}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>

<!-- particles -->
<img id="logoFloat" class="logo" src="logo.gif" alt="NOLA Logo">

<!-- top-right connect -->
<div class="top-right-connect">
  <div id="addrChip" class="addr-chip" aria-hidden="true"></div>
  <button id="connectFloating" class="connect-floating glassy-btn" title="Connect Wallet" aria-haspopup="dialog" aria-controls="walletModal">
    <span id="connectIcon" style="margin-right:8px">ðŸ”Œ</span>
    <span id="connectLabel">Connect Wallet</span>
  </button>
</div>

<!-- SECTION WRAPPER centers card and swap control -->
<div class="section-wrapper">
  <div class="container" role="main" aria-label="NOLA Exchange">
    <h2>NOLA Exchange</h2>

    <!-- FROM -->
    <div class="input-box" id="fromBox" style="position:relative;">
      <div class="left">
        <div class="token-icon" id="fromIcon">
          <img id="fromLogo" src="" alt="" style="display:none">
          <span class="token-chip" id="fromChip" style="display:none"></span>
        </div>

        <div class="token-info">
          <div class="token-symbol" id="fromSymbol">Select</div>
          <div class="token-change" id="fromChange" style="display:none">+0.00%</div>
        </div>

        <div class="input-field">
          <input id="fromToken" placeholder="Token symbol or contract (paste address too)" style="padding:8px 10px;border-radius:8px;border:none;background:transparent;color:#fff;width:100%">
        </div>

        <div class="input-amount" style="min-width:120px;">
          <input id="fromAmount" placeholder="Amount" type="number" step="any" min="0">
        </div>

        <div class="price-small">
          <div id="fromUsdSmall" class="price-usd" style="display:none">â‰ˆ $â€”</div>
          <div id="fromUnitSmall" class="price-unit" style="display:none">â€” / unit</div>
        </div>

      </div>
      <div class="suggestions" id="fromSuggestions" data-side="from" tabindex="-1"></div>
    </div>

    <!-- TO -->
    <div class="input-box" id="toBox" style="position:relative;margin-top:12px;">
      <div class="left">
        <div class="token-icon" id="toIcon">
          <img id="toLogo" src="" alt="" style="display:none">
          <span class="token-chip" id="toChip" style="display:none"></span>
        </div>

        <div class="token-info">
          <div class="token-symbol" id="toSymbol">Select</div>
          <div class="token-change" id="toChange" style="display:none">+0.00%</div>
        </div>

        <div class="input-field">
          <input id="toToken" placeholder="Token symbol or contract (paste address too)" style="padding:8px 10px;border-radius:8px;border:none;background:transparent;color:#fff;width:100%">
        </div>

        <div class="input-amount" style="min-width:120px;">
          <input id="toAmount" placeholder="Estimate" readonly>
        </div>

        <div class="price-small">
          <div id="toUsdSmall" class="price-usd" style="display:none">â‰ˆ $â€”</div>
          <div id="toUnitSmall" class="price-unit" style="display:none">â€” / unit</div>
        </div>

      </div>
      <div class="suggestions" id="toSuggestions" data-side="to" tabindex="-1"></div>
    </div>

    <!-- CONTROLS -->
    <div class="controls" style="margin-top:14px;">
      <div style="display:flex;align-items:center;gap:10px;">
        <div id="swapOutside" class="swap-outside" title="Swap From â†” To">â‡…</div>
      </div>

      <div style="display:flex;align-items:center;gap:10px;">
        <!-- custom slippage -->
        <div class="slippage-wrap" id="slippageWrap" aria-label="Slippage">
          <div id="slippageDisplay" class="slippage-display" role="button" aria-haspopup="listbox" aria-expanded="false">
            <span id="slippageLabel">1%</span>
          </div>
          <div id="slippageList" class="slippage-list" role="listbox" tabindex="-1">
            <div class="slippage-item" data-value="0.5">0.5%</div>
            <div class="slippage-item" data-value="1">1%</div>
            <div class="slippage-item" data-value="2">2%</div>
            <div class="slippage-item" data-value="3">3%</div>
          </div>
        </div>
      </div>
    </div>

    <div class="swap-row" style="margin-top:8px;">
      <!-- main swap button (centered) -->
      <button id="swapBtn" class="glassy-btn" title="Swap">
        <span class="icon">â‡„</span>
        <span class="label">Swap</span>
        <span id="swapSpinner" style="margin-left:8px;display:none" class="btn-spinner"></span>
      </button>
    </div>

    <!-- quick swap placed visually under slippage (still within same container) -->
    <div style="display:flex;justify-content:flex-end;margin-top:10px;">
      <button id="quickSwapBtn" class="quick-cta" title="Quick Swap (uses cached quote)">
    
        <span id="quickLabel">Quick Swap</span>
        <span id="quickSpinner" style="display:none" class="btn-spinner"></span>
      </button>
    </div>

  </div>
</div>

<!-- toast container -->
<div id="toastRoot" style="pointer-events:none;position:fixed;right:18px;bottom:90px;z-index:9999"></div>
  
<!-- CHAT TOGGLE BUTTON -->
<div class="chat-toggle" id="chatToggle">Public ChatðŸ”˜</div>

<!-- CHAT PANEL -->
<div class="chat-sidebar" id="chatSidebar">

  <h3 style="text-align:center;margin-bottom:10px;">Chat</h3>

  <div id="chatMessages" style="overflow-y:auto; flex:1;"></div>

  <div class="chat-input">
    <input id="chatInput" placeholder="Drop your alpha...">
    <button id="sendChat">NOLA</button>
  </div>

</div>

<!-- USERNAME POPUP -->
<div id="usernameModal">
  <div class="modal-content">
    <h3>Choose a Username</h3>
    <input id="modalUsername" placeholder="Enter name">
    <button id="confirmUsername">Say NOLA</button>
  </div>
</div>
<!-- footer -->
<div class="footer">
  <div>Â© 2025 NOLA â€” All rights reserved</div>
  <div><a href="PrivacyTerms.html" id="privacyTerms">Privacy & Terms</a> â€¢ <a href="#" id="xLink">X</a> <a href="#" id="tgLink">Telegram</a> <a href="#" id="siteLink">Website</a></div>
</div>

<!-- LIBS -->
<script src="https://cdn.jsdelivr.net/npm/ethers/dist/ethers.min.js"></script>
<script src="https://unpkg.com/@web3modal/html@2.1.1/dist/index.js"></script>
<script src="https://unpkg.com/@walletconnect/web3modal@2.6.4/dist/w3m.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
/* ====== CONFIG ====== */
const SUPABASE_URL = "https://qnpeauoskuipzcoaqbpy.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFucGVhdW9za3VpcHpjb2FxYnB5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MDU2MjksImV4cCI6MjA3OTk4MTYyOX0.zduOSQAt7FALN61IIEZiQDEcJjHu7vZ2STufC5laDcg";

/* ====== INIT CLIENT ====== */
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

/* ====== ELEMENTS ====== */
const chatSidebar = document.getElementById("chatSidebar");
const chatToggle   = document.getElementById("chatToggle");
const chatMessages = document.getElementById("chatMessages");
const chatInput    = document.getElementById("chatInput");
const sendChatBtn  = document.getElementById("sendChat");

const usernameModal = document.getElementById("usernameModal");
const modalUsername = document.getElementById("modalUsername");
const confirmUsername = document.getElementById("confirmUsername");

/* ====== STATE ====== */
let chatUser = localStorage.getItem("chatUser") || null;
let renderedIds = new Set(); 
let lastId = 0; // track highest id rendered

/* ====== UI: show modal if username missing ====== */
if(!chatUser){
  usernameModal.style.display = "flex";
} else if(modalUsername) {
  modalUsername.value = chatUser;
}

/* ====== username logic ====== */
confirmUsername && (confirmUsername.onclick = async () => {
  const v = (modalUsername.value || '').trim();
  chatUser = v || ('User' + Math.floor(Math.random()*9999));
  localStorage.setItem('chatUser', chatUser);
  usernameModal.style.display = 'none';
  await initChat();
});

/* if username already exists */
if(chatUser){
  initChat();
}

/* ====== Help: color only usernames ====== */
const userColors = {};
function getColor(name){
  if(userColors[name]) return userColors[name];
  const r = Math.floor(100 + Math.random()*120);
  const g = Math.floor(50 + Math.random()*140);
  const b = Math.floor(100 + Math.random()*120);
  const col = `rgb(${r},${g},${b})`;
  userColors[name] = col;
  return col;
}

/* ====== Render message safely ====== */
function escapeHtml(s){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function renderMessage(msg){
  if(!msg || !msg.id) return;
  if(renderedIds.has(String(msg.id))) return; 
  renderedIds.add(String(msg.id));

  const numericId = Number(msg.id);
  if(!Number.isNaN(numericId) && numericId > lastId) lastId = numericId;

  const el = document.createElement('div');
  el.className = 'chat-msg';

  const userEsc = escapeHtml(msg.user || 'Anon');
  const textEsc = escapeHtml(msg.text || '');
  const time = msg.created_at ? new Date(msg.created_at).toLocaleTimeString() : '';

  el.innerHTML = `
    <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
      <b style="color:${getColor(userEsc)};font-weight:800">${userEsc}</b>
      <span style="font-size:11px;color:rgba(255,255,255,0.5);margin-left:auto">${time}</span>
    </div>
    <div style="margin-top:6px;white-space:pre-wrap">${textEsc}</div>
  `;

  chatMessages.appendChild(el);

  while(chatMessages.children.length > 500){
    chatMessages.removeChild(chatMessages.firstChild);
  }
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function showPlaceholder(){
  chatMessages.innerHTML = `<div style="opacity:0.7;text-align:center;margin-top:20px">No messages yet â€” be first!</div>`;
}

/* ====== Load history ====== */
async function loadHistory(){
  try{
    const { data, error } = await supabase
      .from('chat_messages')
      .select('id, user, text, created_at')
      .order('id', { ascending: true })
      .limit(200);

    if(error){
      console.error('History load error', error);
      chatMessages.innerHTML = `<div style="color:#f88;text-align:center">Failed to load chat history</div>`;
      return;
    }

    renderedIds.clear();
    chatMessages.innerHTML = '';
    if(!data || !data.length){
      showPlaceholder();
      lastId = 0;
      return;
    }

    data.forEach(renderMessage);
  }catch(err){
    console.error('loadHistory exception', err);
    chatMessages.innerHTML = `<div style="color:#f88;text-align:center">Chat unavailable</div>`;
  }
}

/* ====== Polling: fetch new messages every 1.5s ====== */
async function fetchNewMessages() {
    try {
        const { data, error } = await supabase
            .from('chat_messages')
            .select('id, user, text, created_at')
            .gt('id', lastId)
            .order('id', { ascending: true });

        if(error){
            console.error('Fetch new messages error:', error);
            return;
        }

        if(data && data.length){
            data.forEach(renderMessage);
        }
    } catch (e) {
        console.error('fetchNewMessages exception:', e);
    }
}
setInterval(fetchNewMessages, 1500);

/* ====== Send message ====== */
let sending = false;
sendChatBtn.addEventListener('click', async () => {
  const text = (chatInput.value || '').trim();
  if(!text) return;
  if(!chatUser){
    usernameModal.style.display = 'flex';
    return;
  }
  if(sending) return;
  sending = true;
  sendChatBtn.disabled = true;

  try{
    const { data, error } = await supabase
      .from('chat_messages')
      .insert({ user: chatUser, text });

    if(error){
      console.error('Insert error', error);
      showToast('Send failed. Check console.', { type: 'error' });
    } else if(data && data[0]){
      // local echo
      renderMessage(data[0]);

      // CLEAR the chat input (already done before) and ALSO clear the swap text fields
      chatInput.value = '';
      chatInput.focus();

      // === YOUR REQUEST: clear swap text fields after sending NOLA ===
      try {
        fromToken.value = '';
      } catch(e){}
      try {
        toToken.value = '';
      } catch(e){}
      try {
        fromAmount.value = '';
      } catch(e){}
      try {
        toAmount.value = '';
      } catch(e){}
    }
  }catch(e){
    console.error('Send exception', e);
    showToast('Send failed (exception).', { type: 'error' });
  } finally {
    setTimeout(()=>{ sending=false; sendChatBtn.disabled=false; }, 500);
  }
});

/* ====== Send on Enter ====== */
chatInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault();
    sendChatBtn.click();
  }
});

/* ====== Toggle chat sidebar ====== */
chatToggle && chatToggle.addEventListener('click', () => {
  chatSidebar.classList.toggle('open');
});

/* ====== Clicking the page should CLOSE the chat (reversed behavior) ====== */
document.querySelectorAll('.section-wrapper, .container').forEach(el=>{
  el.addEventListener('click', (e) => {
    // if click was inside suggestions or inputs, don't change chat
    const insideSuggestion = !!e.target.closest('.suggestions');
    const insideInput = !!e.target.closest('input, button, .glassy-btn, .quick-cta');
    if (insideSuggestion || insideInput) return;
    // close chat (reverse of old behavior)
    chatSidebar.classList.remove('open');
  });
});

/* ====== Init chat ====== */
async function initChat(){
  await loadHistory();
}
</script>

<script>
  /* ================= PARTICLES */
(function createParticles(){ for(let i=0;i<60;i++){ const p=document.createElement('div'); p.className='particle'; p.style.top=(Math.random()*100)+'%'; p.style.left=(Math.random()*100)+'%'; p.style.width=(Math.random()*3+1)+'px'; p.style.height=(Math.random()*3+1)+'px'; p.style.animationDuration=(Math.random()*10+5)+'s'; document.body.appendChild(p); }})();

/* =================== CONFIG & STATE =================== */
const CHAIN_ID = 137;
const CHAIN_ID_HEX = '0x89';
const ONEINCH_BASE = `https://api.1inch.io/v5.0/${CHAIN_ID}`;
const ZEROX_BASE = 'https://polygon.api.0x.org';
const COINGECKO_CHAIN = 'polygon-pos';
const FALLBACK_RPCS = [
  "https://polygon-rpc.com",
   "https://rpc-mainnet.maticvigil.com",
];
const USDC_ADDR = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const WETH_ADDR = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619';
const MATIC_ADDR = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const ZEROX_API_KEY = '099490ac-79a1-4416-a088-df38b6e0c384';
const WALLETCONNECT_PROJECT_ID = '6557a92e3698182727669d41cbeb95a1';
const FEE_PERCENT = 0.00001;
const FEE_RECIPIENT = '0xFEE_RECIPIENT_PLACEHOLDER';
const QUOTE_CACHE_TTL = 10_000; // 10s

let tokenList = [];
let tokenMap = new Map();
let cgStatsMap = new Map();
const priceCache = new Map();
const suggestionCache = new Map();
const quoteCache = new Map();
const ACTIVE_PRICE_ADDRS = new Set();

/* UI refs */
const $ = id => document.getElementById(id);
const fromToken = $('fromToken'), toToken = $('toToken');
const fromAmount = $('fromAmount'), toAmount = $('toAmount');
const fromUsdSmall = $('fromUsdSmall'), toUsdSmall = $('toUsdSmall');
const fromUnitSmall = $('fromUnitSmall'), toUnitSmall = $('toUnitSmall');
const fromLogo = $('fromLogo'), toLogo = $('toLogo');
const fromChip = $('fromChip'), toChip = $('toChip');
const fromSuggestions = $('fromSuggestions'), toSuggestions = $('toSuggestions');
const swapOutside = $('swapOutside'), swapBtn = $('swapBtn'), swapSpinner = $('swapSpinner');
const fromBox = $('fromBox'), toBox = $('toBox');
const connectFloating = $('connectFloating'), addrChip = $('addrChip'), connectLabel = $('connectLabel'), connectIcon = $('connectIcon');
const slippageWrap = $('slippageWrap'), slippageDisplay = $('slippageDisplay'), slippageList = $('slippageList'), slippageLabel = $('slippageLabel');
const fromChangeEl = $('fromChange'), toChangeEl = $('toChange');
const quickSwapBtn = $('quickSwapBtn'), quickSpinner = $('quickSpinner'), quickLabel = $('quickLabel');

let provider = null, signer = null, userAddress = null, web3modal = null;

/* Ensure FROM/TO inputs always show the selected token symbol after blur and hide symbol on focus */
function hideSymbolOnFocus(side){
  const sym = (side==='from')? $('fromSymbol') : $('toSymbol');
  if (sym) sym.style.visibility = 'hidden';
}
function restoreSymbolOnBlur(side){
  const input = (side==='from')? $('fromToken') : $('toToken');
  const sym = (side==='from')? $('fromSymbol') : $('toSymbol');
  try {
    const addr = input.dataset.address;
    if ((!input.value || input.value.trim()==='') && addr && tokenMap.has(low(addr))) {
      const tk = tokenMap.get(low(addr));
      input.value = tk.symbol || tk.name || addr.slice(0,8);
    } else if (!input.value || input.value.trim()==='') {
      if(sym) sym.textContent = 'Select';
    }
    if (addr && tokenMap.has(low(addr))) {
      if(sym) sym.textContent = tokenMap.get(low(addr)).symbol || tokenMap.get(low(addr)).name || 'Select';
    }
    if(sym) sym.style.visibility = 'visible';
  } catch(e){}
}
fromToken.addEventListener('focus', ()=> hideSymbolOnFocus('from'));
toToken.addEventListener('focus', ()=> hideSymbolOnFocus('to'));
fromToken.addEventListener('blur', ()=> restoreSymbolOnBlur('from'));
toToken.addEventListener('blur', ()=> restoreSymbolOnBlur('to'));

/* =================== HELPERS =================== */
const isAddress = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
const low = s => (s||'').toLowerCase();
const nowTs = ()=> Date.now();
function formatUSD(v){ if (v===null||v===undefined||!Number.isFinite(v)) return 'â€”'; const n=Number(v); const opts={style:'currency',currency:'USD',maximumFractionDigits:2,minimumFractionDigits:2}; if(Math.abs(n)>0&&Math.abs(n)<0.01){opts.maximumFractionDigits=6;opts.minimumFractionDigits=4;} return new Intl.NumberFormat('en-US',opts).format(n); }
function fetchWithTimeout(url,opts={},ms=5000){ const controller=new AbortController(); const id=setTimeout(()=>controller.abort(),ms); const init=Object.assign({},opts,{signal:controller.signal}); return fetch(url,init).finally(()=>clearTimeout(id)); }
function explorerTxLink(tx){ return `https://polygonscan.com/tx/${tx}`; }

/* single-themed toast queue (keep one at a time) */
let _toastQueue = [];
let _toastVisible = false;
function showToast(msg, opts = {}) {
  opts = Object.assign({ttl:4000, type:'info'}, opts);
  _toastQueue.push({msg, opts});
  if (!_toastVisible) _processToastQueue();
}
function _processToastQueue(){
  if (_toastQueue.length === 0) { _toastVisible = false; return; }
  _toastVisible = true;
  const item = _toastQueue.shift();
  const root = $('toastRoot');
  const el = document.createElement('div');
  el.className = 'toast';
  el.style.pointerEvents = 'auto';
  el.innerHTML = `<div style="display:flex;gap:10px;align-items:center">
    <div style="flex:1">${item.msg}</div>
    ${item.opts.txHash ? `<div style="font-size:12px;margin-left:8px"><a href="${explorerTxLink(item.opts.txHash)}" target="_blank" rel="noopener">View</a></div>` : ''}
  </div>`;
  root.appendChild(el);
  el.style.opacity = '0';
  requestAnimationFrame(()=>{ el.style.transition = 'opacity 180ms ease, transform 180ms ease'; el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
  setTimeout(()=> {
    el.style.transition = 'opacity 220ms'; el.style.opacity = '0';
    setTimeout(()=>{ el.remove(); _processToastQueue(); }, 260);
  }, item.opts.ttl);
}

/* spinner + busy helper */
function setBusy(el, busy = true, label) {
  if (!el) return;
  if (busy) {
    el.setAttribute('disabled', 'true');
    const spinner = el.querySelector('.btn-spinner') || el.parentElement.querySelector('.btn-spinner');
    if (spinner) spinner.style.display = 'inline-block';
    if (label) { const lbl = el.querySelector('.label') || el.querySelector('span'); if (lbl) lbl.textContent = label; }
  } else {
    el.removeAttribute('disabled');
    const spinner = el.querySelector('.btn-spinner') || el.parentElement.querySelector('.btn-spinner');
    if (spinner) spinner.style.display = 'none';
  }
}

/* prevent/allow body scroll while suggestions open */
let _bodyScrollLocked = false;
function stopBodyScroll(){
  if (_bodyScrollLocked) return;
  _bodyScrollLocked = true;
  document.documentElement.style.overflow = 'hidden';
  document.body.style.overflow = 'hidden';
}
function restoreBodyScroll(){
  if (!_bodyScrollLocked) return;
  _bodyScrollLocked = false;
  document.documentElement.style.overflow = '';
  document.body.style.overflow = '';
}

/* RPC provider fallback chooser */
async function getRpcProvider(){
  for (const url of FALLBACK_RPCS){
    try {
      const p = new ethers.providers.JsonRpcProvider(url);
      const net = await p.getNetwork();
      if (net && net.chainId === CHAIN_ID) return p;
    } catch(e){}
  }
  return new ethers.providers.JsonRpcProvider(FALLBACK_RPCS[0]);
}

/* =================== LOAD TOKENS & COINGECKO MARKETS =================== */
async function loadTokensAndMarkets(){
  try {
    const r = await fetch('https://tokens.coingecko.com/polygon-pos/all.json');
    const j = await r.json();
    tokenList = (j.tokens||[]).map(t => ({ address: low(t.address), symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||t.logo||'' }));
    tokenList.forEach(t => tokenMap.set(t.address, t));
    if (!tokenMap.has(low(MATIC_ADDR))) tokenMap.set(low(MATIC_ADDR), { address: low(MATIC_ADDR), symbol:'MATIC', name:'Polygon', decimals:18, logoURI: '' });

    try {
      const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`;
      const rm = await fetchWithTimeout(marketsUrl, {}, 5000);
      const jm = await rm.json();
      jm.forEach(c => {
        const sym = low(c.symbol||''), name = low(c.name||'');
        const stat = { price: (typeof c.current_price === 'number' ? c.current_price : null), change: (typeof c.price_change_percentage_24h === 'number' ? c.price_change_percentage_24h : null), changePeriod:'24h', volume24h: (typeof c.total_volume === 'number' ? c.total_volume : 0), image: c.image||'', volume12h: null };
        if (sym) cgStatsMap.set(sym, stat);
        if (name) cgStatsMap.set(name, stat);
      });
    } catch(e){ console.warn('CoinGecko markets failed', e); }

    try {
      const r1 = await fetch(`${ONEINCH_BASE}/tokens`);
      const j1 = await r1.json();
      if (j1 && j1.tokens) {
        Object.values(j1.tokens).forEach(t => {
          const addr = low(t.address||'');
          if (!addr) return;
          if (tokenMap.has(addr)) return;
          const obj = { address: addr, symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||'' };
          tokenList.push(obj); tokenMap.set(addr, obj);
        });
      }
    } catch(e){ /* ignore */ }

    const seen = new Set();
    tokenList = tokenList.filter(t => { if(!t||!t.address) return false; if(seen.has(t.address)) return false; seen.add(t.address); return true; });
    console.log('Loaded tokens:', tokenList.length);
  } catch(e){ console.error('loadTokensAndMarkets error', e); }
}
let tokensLoadedPromise = loadTokensAndMarkets();
async function ensureTokensLoaded(){ if (!tokensLoadedPromise) tokensLoadedPromise = loadTokensAndMarkets(); await tokensLoadedPromise; }

/* =================== PRICING SOURCES & SMART PRICE =================== */

async function fetchCoingeckoSimple(idOrSymbol){
  try {
    const q = isAddress(idOrSymbol) ? `contract_addresses=${idOrSymbol}` : `ids=${encodeURIComponent(idOrSymbol)}`;
    const url = isAddress(idOrSymbol) ? `https://api.coingecko.com/api/v3/coins/polygon-pos/contract/${idOrSymbol}` : `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${encodeURIComponent(idOrSymbol)}`;
    const r = await fetchWithTimeout(url, {}, 5000);
    const j = await r.json();
    if (!j) return null;
    if (Array.isArray(j) && j.length) return j[0].current_price || null;
    if (j && j.market_data && j.market_data.current_price) return j.market_data.current_price.usd || null;
    if (j && j.current_price) return j.current_price || null;
    return null;
  } catch(e){ return null; }
}

async function fetchDexscreenerPrice(symbol){
  try {
    const q = encodeURIComponent(symbol);
    const r = await fetchWithTimeout(`https://api.dexscreener.com/latest/dex/search?q=${q}`, {}, 4000);
    const j = await r.json();
    if (j && j.pairs && j.pairs.length) {
      const p = j.pairs[0];
      return p && p.priceUsd ? Number(p.priceUsd) : null;
    }
    return null;
  } catch(e){ return null; }
}

async function getTokenPriceUSD(addrOrSymbol){
  try {
    const key = low(addrOrSymbol || '');
    if (priceCache.has(key)) {
      const v = priceCache.get(key);
      if (nowTs() - v.ts < 60_000) return v.price;
    }
    // Try coingecko symbol map
    let p = null;
    if (!isAddress(key)) {
      const cg = cgStatsMap.get(key) || null;
      if (cg && cg.price) p = cg.price;
    } else {
      p = await fetchCoingeckoSimple(key);
    }
    if (!p) {
      p = await fetchDexscreenerPrice(key);
    }
    priceCache.set(key, { price: p, ts: nowTs() });
    return p;
  } catch(e){ return null; }
}

/* =================== SUGGESTIONS & AUTOCOMPLETE (with scroll-lock) =================== */

function makeSuggestionItem(tokenObj, stats, priceUSD){
  const row = document.createElement('div'); row.className='suggestion-item';
  const left = document.createElement('div'); left.className='suggestion-left';
  const img = document.createElement('img'); img.src = tokenObj.logoURI || (stats && stats.image) || '';
  img.onerror = ()=> img.src = '';
  img.style.width='28px'; img.style.height='28px'; img.style.borderRadius='50%';
  left.appendChild(img);
  const main = document.createElement('div'); main.className='suggestion-main';
  const sym = document.createElement('div'); sym.className='suggestion-symbol'; sym.textContent = tokenObj.symbol || (tokenObj.address?tokenObj.address.slice(0,6):'');
  const nm = document.createElement('div'); nm.className='suggestion-name'; nm.textContent = tokenObj.name || '';
  main.appendChild(sym); main.appendChild(nm);
  if (stats && (typeof stats.change === 'number' || typeof stats.change24h === 'number' || typeof stats.change !== 'undefined')) {
    const changeVal = (typeof stats.change === 'number') ? stats.change : (typeof stats.change24h === 'number' ? stats.change24h : null);
    const period = stats.changePeriod || (stats.change24h ? '24h' : '');
    if (changeVal !== null && changeVal !== undefined) {
      const ch = document.createElement('div'); ch.style.fontSize='11px'; ch.style.marginTop='6px'; ch.style.opacity='0.9';
      ch.textContent = (changeVal>=0?'+':'')+changeVal.toFixed(2) + (period ? ` (${period})` : '');
      ch.style.color = changeVal >= 0 ? '#9ef39e' : '#ff9e9e';
      main.appendChild(ch);
    }
  }
  left.appendChild(main);
  row.appendChild(left);
  const right = document.createElement('div'); right.className='suggestion-price-pill';
  if (priceUSD != null && Number.isFinite(priceUSD)) right.textContent = formatUSD(priceUSD);
  else right.textContent = 'â€”';
  row.appendChild(right);
  return row;
}

function showDefaultList(side){
  const box = (side === 'from') ? fromSuggestions : toSuggestions;
  box.innerHTML = '';
  const top = tokenList.slice(0, 30);
  top.forEach(t => {
    const s = cgStatsMap.get(low(t.symbol||'')) || {};
    const p = priceCache.has(t.address) ? priceCache.get(t.address).price : null;
    const item = makeSuggestionItem(t, s, p);
    item.addEventListener('click', ()=> applyTokenSelection(side === 'from' ? 'from' : 'to', t));
    box.appendChild(item);
  });
  box.style.display = 'block';
  stopBodyScroll();
}

/* search suggestions */
let suggestionTimer = null;
function showSuggestionsFor(inputEl, side){
  const q = (inputEl.value||'').trim();
  const box = (side === 'from') ? fromSuggestions : toSuggestions;
  box.innerHTML = '';
  if (!q) { showDefaultList(side); return; }
  const results = [];
  const ql = q.toLowerCase();
  for (const t of tokenList) {
    if (t.symbol && t.symbol.toLowerCase().includes(ql)) results.push(t);
    else if (t.name && t.name.toLowerCase().includes(ql)) results.push(t);
    else if (t.address && t.address.toLowerCase().startsWith(ql)) results.push(t);
    if (results.length >= 40) break;
  }
  results.slice(0,40).forEach(t => {
    const s = cgStatsMap.get(low(t.symbol||'')) || {};
    const p = priceCache.has(t.address) ? priceCache.get(t.address).price : null;
    const item = makeSuggestionItem(t, s, p);
    item.addEventListener('click', ()=> applyTokenSelection(side === 'from' ? 'from' : 'to', t));
    box.appendChild(item);
  });
  box.style.display = 'block';
  stopBodyScroll();
}

fromToken.addEventListener('input', (e)=> {
  clearTimeout(suggestionTimer);
  suggestionTimer = setTimeout(()=> showSuggestionsFor(fromToken, 'from'), 160);
});
toToken.addEventListener('input', (e)=> {
  clearTimeout(suggestionTimer);
  suggestionTimer = setTimeout(()=> showSuggestionsFor(toToken, 'to'), 160);
});

/* apply token selection */
function applyTokenSelection(side, tokenObj){
  if (!tokenObj) return;
  const addr = tokenObj.address;
  if (side === 'from') {
    fromToken.dataset.address = addr;
    fromToken.value = tokenObj.symbol || tokenObj.name || addr.slice(0,8);
    fromLogo.src = tokenObj.logoURI || '';
    fromLogo.style.display = tokenObj.logoURI ? 'block' : 'none';
    fromChip.style.display = 'inline-block';
    fromChip.textContent = tokenObj.symbol || '';
    fromBox.classList.add('has-token');
  } else {
    toToken.dataset.address = addr;
    toToken.value = tokenObj.symbol || tokenObj.name || addr.slice(0,8);
    toLogo.src = tokenObj.logoURI || '';
    toLogo.style.display = tokenObj.logoURI ? 'block' : 'none';
    toChip.style.display = 'inline-block';
    toChip.textContent = tokenObj.symbol || '';
    toBox.classList.add('has-token');
  }
  // hide suggestions
  fromSuggestions.style.display = 'none';
  toSuggestions.style.display = 'none';
  restoreBodyScroll();
}

/* Ensure blur normalization (defensive) */
function normalizeSelectedTokenText(inputEl, chipEl) {
  try {
    const addr = low(inputEl.dataset.address || '');
    if (addr && tokenMap.has(addr)) {
      const tok = tokenMap.get(addr);
      inputEl.value = tok.symbol || tok.name || inputEl.value || addr.slice(0,8);
      return;
    }
    if (chipEl && chipEl.textContent) {
      inputEl.value = chipEl.textContent;
    }
  } catch(e){}
}
fromToken.addEventListener('blur', ()=> { setTimeout(()=> normalizeSelectedTokenText(fromToken, fromChip), 120); });
toToken.addEventListener('blur', ()=> { setTimeout(()=> normalizeSelectedTokenText(toToken, toChip), 120); });

/* SLIPPAGE UI */
function toggleSlippageList(open){
  if (open === undefined) open = slippageList.style.display !== 'block';
  if (open) {
    slippageList.style.display = 'block';
    slippageDisplay.setAttribute('aria-expanded', 'true');
    stopBodyScroll();
  } else {
    slippageList.style.display = 'none';
    slippageDisplay.setAttribute('aria-expanded', 'false');
    restoreBodyScroll();
  }
}
slippageDisplay.addEventListener('click', ()=> toggleSlippageList());
slippageList.querySelectorAll('.slippage-item').forEach(it=>{
  it.addEventListener('click', ()=>{
    slippageLabel.textContent = it.dataset.value + '%';
    toggleSlippageList(false);
  });
});
function getSelectedSlippage(){ return (slippageLabel.textContent||'1%').replace('%','').trim(); }

/* =================== CONNECT WALLET & CHAIN SWITCH & MODAL (UPDATED) =================== */

function shortAddr(addr){ return addr ? `${addr.slice(0,6)}â€¦${addr.slice(-4)}` : ''; }
function setConnectedUI(address){
  if(address){ addrChip.style.display = 'inline-block'; addrChip.textContent = shortAddr(address); connectLabel.textContent = 'Connected'; connectIcon.textContent = 'ðŸ”—'; connectFloating.classList.add('connected'); }
  else { addrChip.style.display = 'none'; connectLabel.textContent = 'Connect Wallet'; connectIcon.textContent = 'ðŸ”Œ'; connectFloating.classList.remove('connected'); }
}

async function ensureCorrectChainOrPrompt(){
  try {
    if (!provider) return false;
    let net = null;
    try { net = await provider.getNetwork(); } catch(e){ net = null; }
    if (!net || net.chainId !== CHAIN_ID) {
      if (provider.provider && provider.provider.request) {
        try {
          await provider.provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: CHAIN_ID_HEX }] });
          showToast('Switched network to Polygon', { type: 'success' });
          return true;
        } catch(switchErr){
          showToast('Please switch wallet network to Polygon (chain 137) and retry.', { type: 'warn' });
          throw new Error('wrong-chain');
        }
      } else {
        showToast('Your connected provider is not on Polygon. Switch network to proceed.', { type: 'warn' });
        throw new Error('wrong-chain');
      }
    }
    return true;
  } catch(e){ throw e; }
}

/* Robust UniversalProvider loader (tries UMD cdn and global names) */
async function tryUniversalProviderPairing(){
  const urls = [
    'https://unpkg.com/@walletconnect/universal-provider/dist/umd/index.min.js',
    'https://cdn.jsdelivr.net/npm/@walletconnect/universal-provider/dist/umd/index.min.js'
  ];
  function loadScriptOnce(src, timeout = 8000){
    return new Promise((resolve, reject) => {
      if (window.UniversalProvider || window.WalletConnectUniversalProvider || window.WalletConnectUniversal) {
        return resolve(true);
      }
      const existing = Array.from(document.scripts).find(s => s.src && s.src.includes(src));
      if (existing && (window.UniversalProvider || window.WalletConnectUniversalProvider || window.WalletConnectUniversal)) {
        return resolve(true);
      }
      const s = document.createElement('script');
      s.src = src;
      s.async = true;
      let done = false;
      const tt = setTimeout(()=>{ if (!done) { done = true; s.onerror && s.onerror(); reject(new Error('script load timeout')); } }, timeout);
      s.onload = () => { if (done) return; done = true; clearTimeout(tt); resolve(true); };
      s.onerror = (e) => { if (done) return; done = true; clearTimeout(tt); reject(new Error('script load error')); };
      document.head.appendChild(s);
    });
  }

  for (const url of urls){
    try {
      await loadScriptOnce(url);
      const Up = window.UniversalProvider || window.WalletConnectUniversalProvider || window.WalletConnectUniversal;
      if (!Up) continue;
      let instance = null;
      if (typeof Up.init === 'function') {
        instance = await Up.init({ projectId: WALLETCONNECT_PROJECT_ID });
      } else if (typeof Up.create === 'function') {
        instance = await Up.create({ projectId: WALLETCONNECT_PROJECT_ID });
      } else {
        try { instance = new Up({ projectId: WALLETCONNECT_PROJECT_ID }); } catch(e){}
      }
      if (!instance) continue;
      const pairingURI = instance?.connector?.uri || instance?.pairingUri || instance?.uri || null;
      return { providerInstance: instance, pairingURI };
    } catch(e){
      console.warn('universal-provider load failed for', url, e);
      continue;
    }
  }
  throw new Error('UniversalProvider import/load failed (tried CDNs)');
}

/* FALLBACK modal showing QR + deep-link copy button */
function showPairingModal(pairingURI){
  try {
    let modal = document.getElementById('wcPairModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'wcPairModal';
      modal.style.position = 'fixed';
      modal.style.left = '0';
      modal.style.top = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '99999';
      modal.style.background = 'rgba(0,0,0,0.6)';
      modal.innerHTML = `<div style="background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));padding:18px;border-radius:14px;max-width:420px;width:90%;text-align:center;color:#fff;">
          <h3 style="margin-bottom:8px">WalletConnect pairing</h3>
          <div id="wcQrWrap" style="margin-bottom:12px"><img id="wcQr" alt="qr" style="max-width:220px;max-height:220px"></div>
          <div style="margin-bottom:12px"><button id="wcCopyBtn" class="glassy-btn">Copy URI</button></div>
          <div style="font-size:13px;opacity:0.9">Or open in a mobile wallet that supports WalletConnect v3.</div>
          <div style="margin-top:10px"><button id="wcCloseBtn" class="glassy-btn">Close</button></div>
        </div>`;
      document.body.appendChild(modal);
      document.getElementById('wcCloseBtn').addEventListener('click', ()=> modal.remove());
      document.getElementById('wcCopyBtn').addEventListener('click', ()=> { navigator.clipboard && navigator.clipboard.writeText(pairingURI); showToast('Pairing URI copied', {type:'info'}); });
    }
    const qrEl = document.getElementById('wcQr');
    qrEl.src = `https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=${encodeURIComponent(pairingURI)}`;
    modal.style.display = 'flex';
  } catch(e){ console.warn('showPairingModal failed', e); }
}

/* Improved connectWallet: prefer injected provider (MetaMask/Trust/Coinbase), then modal, then WalletConnect v3 pairing fallback */
async function connectWallet(){
  try{
    // 1) Injected provider first (MetaMask / Trust / Coinbase extension)
    if (window.ethereum) {
      try{
        const ethProvider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await ethProvider.send("eth_requestAccounts", []);
        provider = ethProvider;
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        setConnectedUI(userAddress);
        if (window.ethereum.on) {
          window.ethereum.on('accountsChanged', (accounts)=>{ if (!accounts || accounts.length === 0) { disconnectWallet(false); } else { userAddress = accounts[0]; setConnectedUI(userAddress); }});
          window.ethereum.on('chainChanged', ()=>{ window.location.reload(); });
        }
        await ensureCorrectChainOrPrompt();
        showToast('Wallet connected', { type: 'success' });
        return true;
      } catch(e){
        console.warn('injected connect failed', e);
      }
    }

    // 2) Web3Modal (if available)
    if (web3modal && typeof web3modal.openModal === 'function') {
      try {
        const modalProvider = await web3modal.openModal ? await web3modal.openModal({}) : await web3modal.requestConnection?.();
        if (modalProvider) {
          provider = new ethers.providers.Web3Provider(modalProvider, "any");
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          setConnectedUI(userAddress);
          modalProvider.on && modalProvider.on('accountsChanged', (accounts)=>{ if (!accounts || accounts.length === 0) { disconnectWallet(false); } else { userAddress = accounts[0]; setConnectedUI(userAddress); }});
          modalProvider.on && modalProvider.on('chainChanged', ()=>{ window.location.reload(); });
          await ensureCorrectChainOrPrompt();
          showToast('Wallet connected (via modal)', { type: 'success' });
          return true;
        }
      } catch(e){
        console.warn('web3modal connection failed', e);
      }
    }

    // 3) Try WalletConnect v3 UniversalProvider dynamic loader / pairing (best-effort)
    try {
      const res = await tryUniversalProviderPairing();
      if (res && res.pairingURI) {
        // show pairing QR + copyable URI to user
        showPairingModal(res.pairingURI);
        showToast('WalletConnect pairing URI generated â€” scan QR or copy link.', { type: 'info' });
        return true;
      } else if (res && res.providerInstance) {
        try {
          provider = new ethers.providers.Web3Provider(res.providerInstance, "any");
          signer = provider.getSigner();
          userAddress = await signer.getAddress().catch(()=>null);
          setConnectedUI(userAddress);
          await ensureCorrectChainOrPrompt();
          showToast('Wallet connected (universal provider)', { type: 'success' });
          return true;
        } catch(e){}
      }
    } catch(e){
      console.warn('UniversalProvider pairing failed', e);
    }

    showToast('No wallet available â€” install MetaMask or use the wallet modal', { type: 'warn' });
    return false;

  } catch(e){ console.error('connectWallet error', e); showToast('Connection failed: '+(e.message||e), { type: 'error' }); return false; }
}

/* disconnectWallet unchanged */
async function disconnectWallet(confirmAsk = true){
  try {
    if (confirmAsk && !confirm('Disconnect wallet?')) return;
    try { if (web3modal && web3modal.closeModal) web3modal.closeModal(); } catch(_){}
    provider = null; signer = null; userAddress = null;
    setConnectedUI(null);
    showToast('Wallet disconnected', { type: 'info' });
  } catch(e){ console.warn('disconnect fail', e); }
}

/* connectFloating UI click: toggle connect / disconnect (unchanged) */
connectFloating.addEventListener('click', async ()=>{
  if (userAddress) {
    if (!confirm('Disconnect wallet?')) return;
    await disconnectWallet(false);
  } else {
    setBusy(connectFloating, true);
    try { await connectWallet(); } finally { setBusy(connectFloating, false); }
  }
});

/* Small defensive guard */
if (!chatSidebar) {
  console.warn('chatSidebar missing in DOM â€” chat controls will be disabled.');
  }
</script>   <script>
/* =================== SWAP / QUOTE / APPROVAL / EXECUTION (FULL IMPLEMENTATION) =================== */

/* Helper: fetch 1inch quote */
async function fetch1InchQuote(fromAddress, toAddress, amountWei) {
  try {
    const url = `${ONEINCH_BASE}/quote?fromTokenAddress=${fromAddress}&toTokenAddress=${toAddress}&amount=${amountWei}`;
    const r = await fetchWithTimeout(url, {}, 7000);
    const j = await r.json();
    if (j && j.toTokenAmount) return j;
    return null;
  } catch(e){ console.warn('1inch quote failed', e); return null; }
}

/* Helper: fetch 0x quote */
async function fetch0xQuote(fromAddress, toAddress, amountWei, slippagePercent) {
  try {
    const url = `${ZEROX_BASE}/swap/v1/quote?buyToken=${toAddress}&sellToken=${fromAddress}&sellAmount=${amountWei}`;
    const r = await fetchWithTimeout(url, { headers: { '0x-api-key': ZEROX_API_KEY } }, 8000);
    const j = await r.json();
    if (j && j.to === toAddress) return j;
    return null;
  } catch(e){ console.warn('0x quote failed', e); return null; }
}

/* Convert decimals */
function toWei(amount, decimals){
  try {
    const factor = BigInt(10) ** BigInt(decimals);
    const [intPart, fracPart=''] = String(amount).split('.');
    const whole = BigInt(intPart || '0') * factor;
    const frac = BigInt((fracPart + '0'.repeat(decimals)).slice(0, decimals));
    return (whole + frac).toString();
  } catch(e){ return '0'; }
}

/* Prepare and show quote using best available aggregator */
async function prepareQuote() {
  try {
    const fromAddr = (fromToken.dataset.address || '').trim() || MATIC_ADDR;
    const toAddr = (toToken.dataset.address || '').trim() || USDC_ADDR;
    if (!fromAddr || !toAddr) { showToast('Select both tokens'); return; }
    const amountRaw = Number(fromAmount.value || 0);
    if (!amountRaw || amountRaw <= 0) { showToast('Enter amount'); return; }

    const fromDecimals = tokenMap.has(low(fromAddr)) ? tokenMap.get(low(fromAddr)).decimals : 18;
    const sellAmount = toWei(amountRaw, fromDecimals);

    // try 1inch then 0x
    let q1 = await fetch1InchQuote(fromAddr, toAddr, sellAmount);
    if (q1 && q1.toTokenAmount) {
      const toDecimals = q1.toToken.decimals || (tokenMap.has(low(toAddr)) ? tokenMap.get(low(toAddr)).decimals : 18);
      const toAmount = Number(q1.toTokenAmount) / (10 ** toDecimals);
      toAmountEl.value = toAmount;
      toUsdSmall.style.display = 'block';
      const priceUsd = await getTokenPriceUSD(toAddr) || null;
      toUsdSmall.textContent = priceUsd ? `â‰ˆ ${formatUSD(priceUsd * toAmount)}` : 'â‰ˆ $â€”';
      showToast('Quote prepared (1inch)', { type: 'info' });
      quoteCache.set('last', { engine: '1inch', quote: q1, ts: nowTs() });
      return q1;
    }

    // fallback 0x
    let q0 = await fetch0xQuote(fromAddr, toAddr, sellAmount);
    if (q0 && q0.to) {
      const toAmount = Number(q0.buyAmount) / (10 ** (tokenMap.has(low(toAddr)) ? tokenMap.get(low(toAddr)).decimals : 18));
      toAmountEl.value = toAmount;
      toUsdSmall.style.display = 'block';
      const priceUsd = await getTokenPriceUSD(toAddr) || null;
      toUsdSmall.textContent = priceUsd ? `â‰ˆ ${formatUSD(priceUsd * toAmount)}` : 'â‰ˆ $â€”';
      showToast('Quote prepared (0x)', { type: 'info' });
      quoteCache.set('last', { engine: '0x', quote: q0, ts: nowTs() });
      return q0;
    }

    showToast('Could not produce quote (try different amount or tokens)', { type: 'warn' });
    return null;
  } catch(e){ console.error('prepareQuote error', e); showToast('Quote error', { type:'error' }); return null; }
}

/* Execute swap: best-effort via 1inch or 0x using signer */
async function executeSwap() {
  try {
    if (!provider || !signer) { showToast('Please connect your wallet first', { type: 'warn' }); return; }
    const last = quoteCache.get('last');
    if (!last) {
      showToast('No quote available. Click Quick Swap or prepare quote first.', { type: 'warn' });
      return;
    }

    setBusy(swapBtn, true, 'Swapping...');
    if (last.engine === '1inch') {
      // 1inch "swap" endpoint works via building tx data and sending through signer
      const q = last.quote;
      // If 1inch returned tx data:
      if (q && q.tx) {
        const txReq = { to: q.tx.to, data: q.tx.data, value: q.tx.value ? ethers.BigNumber.from(q.tx.value) : undefined };
        const sent = await signer.sendTransaction(txReq);
        showToast('Swap submitted', { type: 'info', txHash: sent.hash });
        await sent.wait();
        showToast('Swap confirmed', { type: 'success', txHash: sent.hash });
      } else {
        showToast('1inch quote not suitable for direct swap', { type: 'warn' });
      }
    } else if (last.engine === '0x') {
      const q = last.quote;
      if (q && q.to && q.data) {
        // Send raw tx
        const txReq = { to: q.to, data: q.data, value: q.value ? ethers.BigNumber.from(q.value) : undefined };
        const sent = await signer.sendTransaction(txReq);
        showToast('Swap submitted', { type: 'info', txHash: sent.hash });
        await sent.wait();
        showToast('Swap confirmed', { type: 'success', txHash: sent.hash });
      } else {
        showToast('0x quote not suitable for direct swap', { type: 'warn' });
      }
    } else {
      showToast('No compatible quote engine for execution', { type: 'warn' });
    }
  } catch(e){
    console.error('executeSwap error', e);
    showToast('Swap failed: ' + (e.message || e), { type: 'error' });
  } finally {
    setBusy(swapBtn, false);
  }
}

/* QUICK SWAP (uses cached last quote) */
quickSwapBtn.addEventListener('click', async ()=> {
  setBusy(quickSwapBtn, true);
  try {
    const cached = quoteCache.get('last');
    if (!cached || (nowTs() - cached.ts) > 30_000) {
      await prepareQuote();
    }
    await executeSwap();
  } finally {
    setBusy(quickSwapBtn, false);
  }
});

/* WIRE swap btn to prepare then execute (confirm) */
swapBtn.addEventListener('click', async ()=>{
  setBusy(swapBtn, true);
  try {
    const q = await prepareQuote();
    if (!q) return;
    if (!confirm('Confirm swap?')) return;
    await executeSwap();
  } finally {
    setBusy(swapBtn, false);
  }
});

/* Utility: swap the FROM/TO tokens & UI update */
swapOutside.addEventListener('click', ()=>{
  const addrFrom = fromToken.dataset.address || '';
  const addrTo = toToken.dataset.address || '';
  const valFrom = fromAmount.value;
  // exchange addresses
  fromToken.dataset.address = addrTo;
  toToken.dataset.address = addrFrom;
  // swap visible values
  const tempVal = fromToken.value;
  fromToken.value = toToken.value || tempVal;
  toToken.value = tempVal;
  // swap amounts
  fromAmount.value = toAmount.value || '';
  toAmount.value = valFrom || '';
  // swap logos/chips
  const tmpLogoSrc = fromLogo.src; fromLogo.src = toLogo.src || tmpLogoSrc; toLogo.src = tmpLogoSrc;
  const tmpChip = fromChip.textContent; fromChip.textContent = toChip.textContent || tmpChip; toChip.textContent = tmpChip;
});

/* Small initialization */
(async function boot(){
  await ensureTokensLoaded();
  // show defaults
  showDefaultList('from');
  showDefaultList('to');
})();
</script>
</body>
</html>
