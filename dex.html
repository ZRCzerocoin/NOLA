<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NOLA DEX</title>
<style>
    body {
        background:#0b0b0b; color:white; font-family:Arial;
        padding:20px;
    }
    .card {
        background:#111; padding:20px; border-radius:16px;
        max-width:420px; margin:auto; box-shadow:0 0 20px #000;
    }
    .row { display:flex; justify-content:space-between; align-items:center; margin:10px 0; }
    .token-btn {
        background:#1c1c1c; padding:10px 14px; border-radius:12px;
        display:flex; align-items:center; gap:8px; cursor:pointer;
    }
    .token-btn img {
        width:26px; height:26px; border-radius:50%; background:#333;
    }
    .input-box {
        background:#1c1c1c; padding:12px; border-radius:12px;
        width:100%; color:white; font-size:18px; border:none;
    }
    #modal {
        position:fixed; top:0; left:0; width:100%; height:100%;
        background:rgba(0,0,0,0.85); display:none; padding:30px;
    }
    .token-item {
        padding:10px; display:flex; align-items:center; gap:10px;
        border-bottom:1px solid #222; cursor:pointer;
    }
    .token-item img { width:32px; height:32px; border-radius:50%; background:#333; }

    /* minimal spinner styling (non-intrusive) */
    .spinner {
        display:inline-block;
        width:14px;
        height:14px;
        border:2px solid rgba(255,255,255,0.12);
        border-top-color:#fff;
        border-radius:50%;
        animation:spin .7s linear infinite;
        vertical-align:middle;
        margin-left:8px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<div class="card">

    <h2>NOLA DEX Aggregator</h2>

    <!-- FROM -->
    <div class="row">
        <input id="fromAmount" class="input-box" placeholder="0.0" />
        <div id="fromTokenBtn" class="token-btn">
            <img id="fromIcon" src="">
            <span id="fromSymbol">Select</span>
        </div>
    </div>
    <div id="fromUsd" style="color:#777; font-size:14px;">$0.00</div>

    <!-- TO -->
    <div class="row">
        <input id="toAmount" class="input-box" placeholder="0.0" />
        <div id="toTokenBtn" class="token-btn">
            <img id="toIcon" src="">
            <span id="toSymbol">Select</span>
        </div>
    </div>
    <div id="toUsd" style="color:#777; font-size:14px;">$0.00</div>

    <button id="swapBtn" style="width:100%; margin-top:20px; padding:14px;
        font-size:18px; border:none; border-radius:12px; background:#4a00ff; color:white;">
        Swap Now
    </button>
</div>

<!-- Token Modal -->
<div id="modal">
    <input id="modalSearch" class="input-box" placeholder="Search name or contract..." style="margin-bottom:20px;">
    <div id="tokenList"></div>
</div>

<script>
/*
  IMPORTANT: UI unchanged. Only logic added/updated below:
  - live price polling every 6s
  - multi-route price fetch: 1inch -> CoinGecko -> DexScreener
  - per-route timeout 3500ms
  - spinner shown while fetching per-side
  - conversion uses 1inch quote
*/

/* CONFIG */
const CHAIN = "137"; // Polygon chain id used with 1inch endpoints
const ONEINCH_USDC = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'; // USDC on polygon
const ROUTE_TIMEOUT = 3500; // ms per route attempt
const POLL_INTERVAL = 6000; // ms live update

/* STATE */
let selecting = null;
let tokensCache = { from: null, to: null };

/* DOM refs */
const fromAmountEl = document.getElementById('fromAmount');
const toAmountEl   = document.getElementById('toAmount');
const fromUsdEl    = document.getElementById('fromUsd');
const toUsdEl      = document.getElementById('toUsd');
const fromSymbolEl = document.getElementById('fromSymbol');
const toSymbolEl   = document.getElementById('toSymbol');
const fromIconEl   = document.getElementById('fromIcon');
const toIconEl     = document.getElementById('toIcon');

document.getElementById("fromTokenBtn").onclick = () => openModal("from");
document.getElementById("toTokenBtn").onclick = () => openModal("to");
document.getElementById("modalSearch").oninput = debounce(searchToken, 300);
fromAmountEl.addEventListener('input', () => { updateConversion("from"); updateUSD("from"); });
toAmountEl.addEventListener('input', () => { updateConversion("to"); updateUSD("to"); });

/* MODAL open */
function openModal(side) {
    selecting = side;
    document.getElementById("modal").style.display = "block";
    document.getElementById("modalSearch").value = "";
    document.getElementById("tokenList").innerHTML = "";
}

/* TOKEN SEARCH - uses 1inch token search */
async function searchToken() {
    const q = document.getElementById("modalSearch").value.trim();
    if (q.length < 1) return;

    try {
        const res = await fetch(`https://api.1inch.dev/token/v1.2/${CHAIN}/search?query=${encodeURIComponent(q)}`, {
            headers: { "Authorization": "Bearer public" }
        });
        const data = await res.json();
        showTokenList(Object.values(data.tokens || {}));
    } catch (e) {
        // fail silently
        document.getElementById("tokenList").innerHTML = '<div style="padding:12px;color:#aaa">Search failed</div>';
    }
}

function showTokenList(list) {
    const box = document.getElementById("tokenList");
    box.innerHTML = "";
    if (!list || !list.length) {
        box.innerHTML = '<div style="padding:12px;color:#aaa">No tokens found</div>';
        return;
    }
    list.forEach(t => {
        const item = document.createElement("div");
        item.className = "token-item";
        item.innerHTML = `
            <img src="${t.logoURI || ''}">
            <div><b>${t.symbol || ''}</b><br><small>${t.name || ''}</small></div>
        `;
        item.onclick = () => selectToken(t);
        box.appendChild(item);
    });
}

/* SELECT TOKEN */
function selectToken(t) {
    if (!selecting) return;
    tokensCache[selecting] = t;
    const symEl = (selecting === 'from') ? fromSymbolEl : toSymbolEl;
    const iconEl = (selecting === 'from') ? fromIconEl : toIconEl;
    symEl.innerText = t.symbol || (t.address ? t.address.slice(0,6) : 'Token');
    iconEl.src = t.logoURI || '';
    document.getElementById("modal").style.display = "none";

    // immediate updates
    updateUSD(selecting);
    if (tokensCache.from && tokensCache.to) updateConversion('from'); // calc estimate
}

/* UTILS: debounce */
function debounce(fn, ms) {
    let t;
    return function(...a){ clearTimeout(t); t = setTimeout(()=> fn.apply(this,a), ms); };
}

/* fetch with timeout (AbortController) */
async function fetchWithTimeout(url, opts = {}, timeout = ROUTE_TIMEOUT) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    try {
        const res = await fetch(url, {...opts, signal: controller.signal});
        clearTimeout(id);
        return res;
    } catch (e) {
        clearTimeout(id);
        throw e;
    }
}

/* promise timeout wrapper that returns null on timeout/error */
async function tryRoute(fn, timeout = ROUTE_TIMEOUT) {
    try {
        return await Promise.race([ fn(), new Promise(res => setTimeout(()=> res(null), timeout)) ]);
    } catch (e) {
        return null;
    }
}

/* PRIMARY: 1inch quote to USDC (1 token) */
async function priceVia1Inch(tokenAddress, tokenDecimals = 18) {
    try {
        // quote 1 token => amount in USDC (6 decimals) if possible
        const oneRaw = BigInt(1) * (BigInt(10) ** BigInt(tokenDecimals));
        const url = `https://api.1inch.dev/swap/v6.0/${CHAIN}/quote?src=${tokenAddress}&dst=${ONEINCH_USDC}&amount=${oneRaw.toString()}`;
        const res = await fetchWithTimeout(url, {}, ROUTE_TIMEOUT);
        const j = await res.json();
        if (j && j.dstAmount) {
            const usdcAmount = Number(j.dstAmount) / 1e6;
            if (usdcAmount > 0) return usdcAmount;
        }
    } catch (e) { /* ignore */ }
    return null;
}

/* CoinGecko fallback (token_price) */
async function priceViaCoinGecko(tokenAddress) {
    try {
        const url = `https://api.coingecko.com/api/v3/simple/token_price/polygon-pos?contract_addresses=${tokenAddress}&vs_currencies=usd`;
        const res = await fetchWithTimeout(url, {}, ROUTE_TIMEOUT);
        const j = await res.json();
        const key = Object.keys(j)[0];
        if (key && j[key] && j[key].usd) return Number(j[key].usd);
    } catch (e) { /* ignore */ }
    return null;
}

/* DexScreener fallback */
async function priceViaDexScreener(tokenAddress) {
    try {
        const res = await fetchWithTimeout(`https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`, {}, ROUTE_TIMEOUT);
        const j = await res.json();
        if (j && j.pairs && j.pairs.length) {
            const p = j.pairs[0].priceUsd;
            if (p) return Number(p);
        }
    } catch (e) { /* ignore */ }
    return null;
}

/* Main multi-route price fetch (1inch -> CoinGecko -> DexScreener) */
async function fetchPriceUSD(tokenAddress, tokenDecimals = 18) {
    if (!tokenAddress) return 0;

    // 1) try 1inch first with timeout
    const p1 = await tryRoute(()=> priceVia1Inch(tokenAddress, tokenDecimals), ROUTE_TIMEOUT);
    if (p1 && p1 > 0) return p1;

    // 2) CoinGecko
    const p2 = await tryRoute(()=> priceViaCoinGecko(tokenAddress), ROUTE_TIMEOUT);
    if (p2 && p2 > 0) return p2;

    // 3) DexScreener
    const p3 = await tryRoute(()=> priceViaDexScreener(tokenAddress), ROUTE_TIMEOUT);
    if (p3 && p3 > 0) return p3;

    // all failed
    return 0;
}

/* show spinner inside USD element */
function showSpinner(el) {
    el.innerHTML = `<span class="spinner"></span>`;
}

/* UPDATE USD field for a side (from/to) */
async function updateUSD(side) {
    const token = tokensCache[side];
    const el = (side === 'from') ? fromUsdEl : toUsdEl;
    if (!token) {
        el.innerText = '$0.00';
        return;
    }
    const amount = Number(document.getElementById(side + 'Amount').value || 0);
    if (!amount) {
        el.innerText = '$0.00';
        return;
    }

    showSpinner(el);

    // fetch price (multi-route)
    const price = await fetchPriceUSD(token.address, token.decimals || 18);

    if (price && price > 0) {
        const total = (price * amount);
        // show with 4 decimal places if < 1, else 2 decimals
        el.innerText = `$${(total < 1 ? total.toFixed(4) : total.toFixed(2))}`;
    } else {
        el.innerText = '$0.00';
    }
}

/* LIVE polling of both prices while tokens selected */
let pollId = null;
function startLivePoll() {
    if (pollId) clearInterval(pollId);
    pollId = setInterval(() => {
        if (tokensCache.from) updateUSD('from');
        if (tokensCache.to) updateUSD('to');
    }, POLL_INTERVAL);
}
startLivePoll();

/* UPDATE conversion estimate between tokens using 1inch quote */
async function updateConversion(source) {
    const from = tokensCache.from;
    const to = tokensCache.to;
    if (!from || !to) return;

    const amount = Number(document.getElementById(source + 'Amount').value || 0);
    if (!amount) {
        document.getElementById('fromUsd').innerText = '$0.00';
        document.getElementById('toUsd').innerText = '$0.00';
        return;
    }

    try {
        // use 1inch quote for the conversion
        const fromDecimals = from.decimals || 18;
        const toDecimals = to.decimals || 18;

        // amountRaw as integer string; caution with big numbers — keep same approach as original
        const rawAmount = String(Math.floor(amount * Math.pow(10, fromDecimals)));

        const res = await fetchWithTimeout(
            `https://api.1inch.dev/swap/v6.0/${CHAIN}/quote?src=${from.address}&dst=${to.address}&amount=${rawAmount}`,
            { headers: { "Authorization": "Bearer public" } },
            ROUTE_TIMEOUT
        );
        const j = await res.json();
        if (j && j.dstAmount) {
            const recv = Number(j.dstAmount) / Math.pow(10, toDecimals);
            if (source === 'from') document.getElementById('toAmount').value = recv;
            else document.getElementById('fromAmount').value = recv;
            // refresh USD for both sides
            updateUSD('from');
            updateUSD('to');
        }
    } catch (e) {
        // if quote fails, keep existing values — do not break UI
    }
}

/* initial hook: start polling (already started), and expose modal close on outside click */
document.addEventListener('click', (e)=> {
    const modal = document.getElementById('modal');
    if (modal.style.display === 'block' && e.target === modal) modal.style.display = 'none';
});

/* keep UI exactly unchanged otherwise */
</script>

</body>
</html>
