<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NOLA Exchange</title>
<style>
/* THEME (kept intact) */
body {margin:0; padding:0; font-family:'Arial',sans-serif; background: radial-gradient(circle at center, #0c0014, #1a002b 80%); color:#fff;}
.container {width:90%; max-width:480px; margin:40px auto; background:rgba(255,255,255,0.05); border-radius:25px; padding:25px; backdrop-filter:blur(18px); box-shadow:0 0 25px rgba(180,0,255,0.3);}
h2{text-align:center; color:#e0b3ff; text-shadow:0 0 8px #b445ff;}
.input-box {margin-top:20px; padding:12px; background:rgba(255,255,255,0.02); border-radius:16px; position:relative;}
.input-box .token-top {display:flex; align-items:center; justify-content:space-between; gap:8px;}
.token-left {display:flex; align-items:center; gap:10px; min-width:140px; overflow:hidden;}
.token-left img { width:36px; height:36px; border-radius:10px; object-fit:cover; flex-shrink:0; display:none;} /* hidden until token chosen */
.token-left input[type="text"]{border:none; background:transparent; color:#fff; font-weight:700; font-size:16px; outline:none; width:100%; min-width:60px;}

/* amount + USD on the right */
.token-right {display:flex; align-items:center; gap:10px;}
.token-right .amount{ padding:8px 10px; border-radius:12px; border:none; background:rgba(255,255,255,0.03); color:#fff; font-size:16px; width:110px; text-align:right; }
.token-right .usd { font-size:13px; opacity:0.9; min-width:110px; text-align:right; display:flex; align-items:center; gap:8px; justify-content:flex-end; flex-direction:column; }

/* small spinner (matches theme) */
.usd-spinner { width:14px; height:14px; display:inline-block; border-radius:50%; border:2px solid rgba(255,255,255,0.08); border-top-color:#b445ff; animation:spin 1s linear infinite; visibility:hidden; }
.usd-spinner.visible { visibility:visible; }
@keyframes spin { to { transform: rotate(360deg); } }

/* suggestions */
.suggestions { position:absolute; top:70px; left:0; width:100%; background:rgba(25,0,50,0.95); border-radius:12px; max-height:300px; overflow-y:auto; display:none; z-index:100; box-shadow:0 6px 20px rgba(0,0,0,0.6);}
.suggestion-item { padding:10px; display:flex; align-items:center; cursor:pointer; justify-content:space-between; border-bottom:1px solid rgba(255,255,255,0.02); }
.suggestion-left { display:flex; gap:10px; align-items:center; min-width:180px; }
.suggestion-left img { width:32px; height:32px; border-radius:8px; object-fit:cover; }
.suggestion-main { display:flex; flex-direction:column; overflow:hidden; }
.suggestion-symbol { font-weight:700; font-size:14px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:200px;}
.suggestion-name { font-size:12px; opacity:0.8; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:200px;}
.suggestion-meta { text-align:right; font-size:12px; opacity:0.9; min-width:92px; display:flex; flex-direction:column; align-items:flex-end; }

.suggestion-change { font-size:11px; opacity:0.85; margin-top:6px; }

/* button styles */
.btn {width:100%; padding:14px; margin-top:20px; border:none; border-radius:20px; background: linear-gradient(135deg,#b445ff,#7013ff); color:#fff; font-size:18px; cursor:pointer;}
footer {text-align:center; margin:30px 0 10px 0; font-size:14px; opacity:0.8;}
footer a{color:#b445ff; text-decoration:none; margin:0 5px;}

/* small controls */
#swapTokensBtn {
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  top:calc(50% - 20px);
  width:36px;
  height:36px;
  border-radius:50%;
  background:rgba(30,20,60,0.8);
  border:2px solid rgba(255,255,255,0.05);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  font-size:16px;
  color:#fff;
  z-index:150;
}
#walletConnectBtn{
  position:fixed;
  top:16px;
  right:16px;
  padding:10px 14px;
  border:none;
  border-radius:14px;
  background: linear-gradient(135deg,#b445ff,#7013ff);
  color:#fff;
  cursor:pointer;
  z-index:999;
  font-weight:600;
}

/* dark blank icon fallback (SVG data URL) */
.icon-fallback {
  background-color:#151225;
  width:36px;
  height:36px;
  border-radius:10px;
  display:inline-block;
}
@media (max-width:420px){
  .token-right .amount { width:86px; font-size:14px; }
  .token-left input[type="text"]{font-size:14px;}
  .token-left img{width:32px;height:32px;}
}
</style>
</head>
<body>

<button id="walletConnectBtn">Connect Wallet</button>

<div class="container">
    <h2>NOLA Exchange</h2>

    <div class="input-box" id="fromBox">
        <div class="token-top">
            <div class="token-left">
                <img id="fromLogo" alt="logo">
                <input type="text" id="fromToken" placeholder="From Token (symbol or contract)" autocomplete="off">
            </div>
            <div class="token-right">
                <input id="fromAmount" class="amount" type="number" placeholder="Amount" min="0" step="any">
                <div id="fromUsd" class="usd"><span class="usd-spinner" id="fromSpinner"></span><div id="fromUsdText">≈ $—</div></div>
            </div>
        </div>
        <div class="suggestions" id="fromSuggestions"></div>
    </div>

    <div id="swapTokensBtn" title="Swap From ↔ To">⇅</div>

    <div class="input-box" id="toBox" style="margin-top:12px;">
        <div class="token-top">
            <div class="token-left">
                <img id="toLogo" alt="logo">
                <input type="text" id="toToken" placeholder="To Token (symbol or contract)" autocomplete="off">
            </div>
            <div class="token-right">
                <input id="toAmount" class="amount" type="number" placeholder="Estimated" readonly>
                <div id="toUsd" class="usd"><span class="usd-spinner" id="toSpinner"></span><div id="toUsdText">≈ $—</div></div>
            </div>
        </div>
        <div class="suggestions" id="toSuggestions"></div>
    </div>

    <div style="margin-top:10px;">
        <select id="slippage" style="padding:8px; border-radius:10px; border:none; background:rgba(255,255,255,0.03); color:#fff;">
            <option value="0.1">0.1%</option>
            <option value="0.5">0.5%</option>
            <option value="1" selected>1%</option>
            <option value="2">2%</option>
        </select>
    </div>

    <button class="btn" id="swapBtn">Swap</button>
</div>

<footer>
&copy; 2025 NOLA | <a href="Terms.html">Privacy & Terms</a> | 
<a href="#" id="nolTokenLink">NOLA Token</a> | 
<a href="#" id="xLink">X</a> | 
<a href="#" id="telegramLink">Telegram</a>
</footer>

<!-- ethers + WalletConnect v1 (kept as you had it for backwards compatibility) -->
<script src="https://cdn.jsdelivr.net/npm/ethers/dist/ethers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider/dist/umd/index.min.js"></script>

<script>
/* CONFIG */
const CHAIN_ID = 137; // Polygon only
const ONEINCH_BASE = `https://api.1inch.io/v5.0/${CHAIN_ID}`;
const COINGECKO_CHAIN = 'polygon-pos';
const FALLBACK_RPC = "https://polygon-rpc.com";
const USDC_ADDR = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'; // USDC on Polygon
const MATIC_ADDR = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // 1inch native placeholder

/* STATE */
let tokenList = [];
let tokenMap = new Map();
let volumeMap = new Map();
let cgStatsMap = new Map();
let provider = null, signer = null, signerAddress = null, walletConnected = false;
const priceCache = new Map(); // address -> { price, ts }

/* HELPERS */
const $ = id => document.getElementById(id);
const isAddress = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
const low = s => (s||'').toLowerCase();
const nowTs = ()=> Date.now();

/* DARK SVG FALLBACK */
const DARK_SVG_PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(
  `<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36"><rect width="100%" height="100%" rx="8" ry="8" fill="#151225"/></svg>`
);

/* format USD professionally */
function formatUSD(value) {
  if (value === null || value === undefined || !Number.isFinite(value)) return '—';
  const n = Number(value);
  // choose digits: tiny numbers get more precision
  const abs = Math.abs(n);
  const opts = { style: 'currency', currency: 'USD', maximumFractionDigits: 2, minimumFractionDigits: 2 };
  if (abs > 0 && abs < 0.01) { opts.maximumFractionDigits = 6; opts.minimumFractionDigits = 4; }
  return new Intl.NumberFormat('en-US', opts).format(n);
}

/* UTILS: throttle */
function throttle(fn, wait) {
  let last = 0, timeout = null;
  return function(...args) {
    const now = Date.now();
    const remaining = wait - (now - last);
    if (remaining <= 0) {
      if (timeout) { clearTimeout(timeout); timeout = null; }
      last = now;
      fn.apply(this, args);
    } else if (!timeout) {
      timeout = setTimeout(() => { last = Date.now(); timeout = null; fn.apply(this, args); }, remaining);
    }
  };
}

/* LOAD token lists (CoinGecko polygon tokens + CoinGecko markets + 1inch merge)
   - CoinGecko primary (polygon tokens)
   - 1inch tokens merged only for autocomplete fallback (deduped; CG wins)
*/
async function loadTokensAndVolumes(){
  try {
    const r = await fetch('https://tokens.coingecko.com/polygon-pos/all.json');
    const j = await r.json();
    tokenList = (j.tokens || []).map(t => ({
      address: low(t.address),
      symbol: t.symbol || '',
      name: t.name || '',
      decimals: t.decimals || 18,
      logoURI: t.logoURI || t.logo || ''
    }));
    tokenList.forEach(t => tokenMap.set(t.address, t));

    // ensure MATIC placeholder
    if (!tokenMap.has(MATIC_ADDR)) {
      const m = { address: MATIC_ADDR, symbol: 'MATIC', name: 'Polygon', decimals: 18, logoURI: '' };
      tokenMap.set(MATIC_ADDR, m);
      tokenList.unshift(m);
    }

    // CoinGecko markets (global top by volume) - used only to enrich tokens present in polygon tokenList
    try {
      const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`;
      const rm = await fetch(marketsUrl);
      const jm = await rm.json();
      // Map stats by symbol and name for tokens that appear in tokenList (polygon)
      jm.forEach(c => {
        const sym = low(c.symbol || '');
        const name = low(c.name || '');
        const stat = { price: (typeof c.current_price === 'number' ? c.current_price : null), change24h: (typeof c.price_change_percentage_24h === 'number' ? c.price_change_percentage_24h : null), volume24h: (typeof c.total_volume === 'number' ? c.total_volume : 0), logo: c.image || '' };
        if (sym) cgStatsMap.set(sym, stat);
        if (name) cgStatsMap.set(name, stat);
        if (c.symbol) volumeMap.set(sym, stat.volume24h || 0);
        if (c.name) volumeMap.set(name, stat.volume24h || 0);
      });
    } catch(e){ console.warn('coingecko markets failed', e); }

    // merge 1inch tokens for fallback/autocomplete (chain-specific)
    try {
      const r1 = await fetch(`${ONEINCH_BASE}/tokens`);
      const j1 = await r1.json();
      if (j1 && j1.tokens) {
        Object.values(j1.tokens).forEach(t => {
          const addr = low(t.address || '');
          if (!addr) return;
          if (tokenMap.has(addr)) return; // keep CG polygon token if exists
          const obj = { address: addr, symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||'' };
          tokenList.push(obj); tokenMap.set(addr, obj);
        });
      }
    } catch(e){ console.warn('1inch tokens merge failed', e); }

    // ensure uniqueness
    const seen = new Set();
    tokenList = tokenList.filter(t => {
      if (!t || !t.address) return false;
      if (seen.has(t.address)) return false;
      seen.add(t.address);
      return true;
    });

  } catch (e) {
    console.error('loadTokensAndVolumes error', e);
  }
}
loadTokensAndVolumes();

/* ON-CHAIN metadata fallback */
async function fetchOnchainTokenInfo(address){
  try {
    const addrL = low(address);
    if (tokenMap.has(addrL)) return tokenMap.get(addrL);
    const rpcProvider = new ethers.providers.JsonRpcProvider(FALLBACK_RPC);
    const abi = ["function symbol() view returns (string)","function name() view returns (string)","function decimals() view returns (uint8)"];
    const c = new ethers.Contract(address, abi, rpcProvider);
    const [symbol, name, decimals] = await Promise.all([ c.symbol().catch(()=>null), c.name().catch(()=>null), c.decimals().catch(()=>18) ]);
    const info = { address: addrL, symbol: symbol || address.slice(0,6), name: name || symbol || address.slice(0,8), decimals: decimals||18, logoURI: '' };
    tokenMap.set(info.address, info);
    if (!tokenList.find(t => t.address === info.address)) tokenList.push(info);
    return info;
  } catch (e) {
    console.warn('fetchOnchainTokenInfo failed', e);
    return null;
  }
}

/* fetch wrappers */
function fetchWithTimeout(url, opts = {}, ms = 3000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), ms);
  const init = Object.assign({}, opts, { signal: controller.signal });
  return fetch(url, init).finally(() => clearTimeout(id));
}

/* 1inch quote for price */
async function fetch1InchQuotePrice(addr, decimals) {
  try {
    const amountBN = ethers.BigNumber.from(10).pow(decimals);
    const qUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${addr}&toTokenAddress=${USDC_ADDR}&amount=${amountBN.toString()}`;
    const res = await fetchWithTimeout(qUrl, {}, 3000);
    if (!res.ok) throw new Error('1inch quote non-ok');
    const j = await res.json();
    if (!j || !j.toTokenAmount) throw new Error('1inch returned no toTokenAmount');
    const usdcAmountBN = ethers.BigNumber.from(j.toTokenAmount);
    const usdc = Number(ethers.utils.formatUnits(usdcAmountBN, j.toToken?.decimals ?? 6));
    if (!Number.isFinite(usdc) || usdc <= 0) throw new Error('invalid 1inch price');
    return usdc;
  } catch (e) { throw e; }
}

/* CoinGecko contract price (if listed on polygon) */
async function fetchCoingeckoContractPrice(addr) {
  try {
    const platform = COINGECKO_CHAIN;
    const url = `https://api.coingecko.com/api/v3/coins/${platform}/contract/${addr}`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('coingecko contract non-ok');
    const j = await res.json();
    const price = j?.market_data?.current_price?.usd;
    const change = j?.market_data?.price_change_percentage_24h;
    if (typeof price === 'number' && price > 0) return { price, change };
    throw new Error('coingecko no price');
  } catch (e) { throw e; }
}

/* Dexscreener fallback */
async function fetchDexscreenerPrice(addr) {
  try {
    const url = `https://api.dexscreener.com/latest/dex/tokens/${addr}`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('dexscreener non-ok');
    const j = await res.json();
    const pairs = j?.pairs || [];
    for (const p of pairs) {
      if (p?.priceUsd) {
        const v = Number(p.priceUsd);
        if (Number.isFinite(v) && v > 0) return v;
      }
      if (p?.price) {
        const v = Number(p.price);
        if (Number.isFinite(v) && v > 0) return v;
      }
    }
    throw new Error('dexscreener no price');
  } catch (e) { throw e; }
}

/* price orchestrator: try coingecko contract -> 1inch -> dexscreener */
async function getTokenPriceUSD(address, decimals = 18) {
  if (!address) return null;
  const addr = low(address);
  const c = priceCache.get(addr);
  if (c && (nowTs() - c.ts) < 30000) return c.price;

  try {
    const cg = await fetchCoingeckoContractPrice(addr);
    if (cg && cg.price) { priceCache.set(addr, { price: cg.price, ts: nowTs() }); return cg.price; }
  } catch(_) {}
  try {
    const v = await fetch1InchQuotePrice(addr, decimals);
    if (v) { priceCache.set(addr, { price: v, ts: nowTs() }); return v; }
  } catch(_) {}
  try {
    const v2 = await fetchDexscreenerPrice(addr);
    if (v2) { priceCache.set(addr, { price: v2, ts: nowTs() }); return v2; }
  } catch(_) {}
  priceCache.set(addr, { price: null, ts: nowTs() });
  return null;
}

/* suggestion item builder */
function makeSuggestionItem(tokenObj, stats, priceUSD){
  const row = document.createElement('div'); row.className = 'suggestion-item';
  const left = document.createElement('div'); left.className = 'suggestion-left';
  const img = document.createElement('img'); img.src = tokenObj.logoURI || stats?.logo || DARK_SVG_PLACEHOLDER; img.onerror = ()=> img.src = DARK_SVG_PLACEHOLDER;
  left.appendChild(img);
  const main = document.createElement('div'); main.className = 'suggestion-main';
  const sym = document.createElement('div'); sym.className = 'suggestion-symbol'; sym.textContent = tokenObj.symbol || (tokenObj.address ? tokenObj.address.slice(0,6) : '');
  const nm = document.createElement('div'); nm.className = 'suggestion-name'; nm.textContent = tokenObj.name || '';
  main.appendChild(sym); main.appendChild(nm); left.appendChild(main);

  const right = document.createElement('div'); right.className = 'suggestion-meta';
  const priceLine = document.createElement('div'); priceLine.textContent = (priceUSD != null && Number.isFinite(priceUSD)) ? formatUSD(priceUSD) : '≈ $—';
  const changeLine = document.createElement('div'); changeLine.className = 'suggestion-change';
  const changeVal = stats?.change24h ?? null;
  if (changeVal !== null && typeof changeVal === 'number') {
    const sign = changeVal >= 0 ? '+' : '';
    changeLine.textContent = `${sign}${changeVal.toFixed(2)}% (24h)`;
    changeLine.style.color = changeVal >= 0 ? '#9ef39e' : '#ff9e9e';
  } else {
    changeLine.textContent = '— (24h)';
    changeLine.style.opacity = 0.75;
  }
  right.appendChild(priceLine); right.appendChild(changeLine);

  row.appendChild(left); row.appendChild(right);
  return row;
}

/* show default CoinGecko top list (polygon tokens only) */
function showDefaultList(side) {
  const box = (side === 'from') ? $('fromSuggestions') : $('toSuggestions');
  box.innerHTML = '';
  // tokens present in tokenList & have CG stats (by symbol or name)
  const candidates = tokenList.filter(t => {
    const s = low(t.symbol), n = low(t.name);
    return (cgStatsMap.has(s) || cgStatsMap.has(n));
  });
  const withStats = candidates.map(t => {
    const s = low(t.symbol), n = low(t.name);
    const stat = cgStatsMap.get(s) || cgStatsMap.get(n) || { price: null, change24h: null, volume24h: 0, logo: '' };
    return { t, stat };
  });
  withStats.sort((a,b) => (b.stat.volume24h || 0) - (a.stat.volume24h || 0));
  const top = withStats.slice(0,20);
  (async () => {
    for (const entry of top) {
      const tk = entry.t;
      const stats = entry.stat;
      let price = stats.price;
      if (!price) price = await getTokenPriceUSD(tk.address, tk.decimals);
      const node = makeSuggestionItem(tk, { change24h: stats.change24h ?? null, logo: tk.logoURI || stats.logo }, price);
      node.addEventListener('click', ()=>{ applyTokenSelection(side, tk); box.style.display='none'; fetchBothPrices(); updateQuoteDebounced(); });
      box.appendChild(node);
    }
    if (top.length) box.style.display='block'; else box.style.display='none';
  })();
}

/* AUTOCOMPLETE setup (default CG top list on focus; typed search merges CG + 1inch fallback) */
function setupAutocomplete(inputId, suggestionsId, side){
  const input = $(inputId), box = $(suggestionsId);
  let timer = null;
  input.addEventListener('input', ()=>{ clearTimeout(timer); timer = setTimeout(()=> handle(input.value.trim().toLowerCase()), 160); });
  input.addEventListener('focus', ()=> {
    const q = input.value.trim().toLowerCase();
    if (!q) showDefaultList(side);
    else handle(q);
  });
  input.addEventListener('blur', ()=> setTimeout(()=> { if (box) box.style.display='none'; }, 180));

  async function handle(q){
    box.innerHTML = ''; if (!q) { box.style.display='none'; return; }

    if (isAddress(q)) {
      let info = tokenMap.get(low(q));
      if (!info) info = await fetchOnchainTokenInfo(q);
      if (info) {
        const stat = cgStatsMap.get(low(info.symbol)) || cgStatsMap.get(low(info.name)) || null;
        let price = stat?.price ?? await getTokenPriceUSD(info.address, info.decimals);
        const node = makeSuggestionItem(info, { change24h: stat?.change24h ?? null, logo: info.logoURI }, price);
        node.addEventListener('click', ()=>{ applyTokenSelection(side, info); box.style.display='none'; fetchBothPrices(); updateQuoteDebounced(); });
        box.appendChild(node); box.style.display='block';
      }
      return;
    }

    // CG matches first (only tokens that exist in tokenList)
    const cgMatches = tokenList.filter(t => {
      const s = t.symbol || '', n = t.name || '';
      const symHasStat = cgStatsMap.has(low(s));
      const nameHasStat = cgStatsMap.has(low(n));
      return (s.toLowerCase().includes(q) || n.toLowerCase().includes(q)) && (symHasStat || nameHasStat);
    });

    const cgScored = cgMatches.map(t => {
      const stats = cgStatsMap.get(low(t.symbol)) || cgStatsMap.get(low(t.name)) || { volume24h: 0, price: null, change24h: null };
      const startBonus = ((t.symbol && t.symbol.toLowerCase().startsWith(q)) || (t.name && t.name.toLowerCase().startsWith(q))) ? 1e12 : 0;
      return { t, stats, score: (stats.volume24h || 0) + startBonus };
    });

    // 1inch fallback matches (from merged tokenList but excluding CG-primary ones)
    const inchMatches = tokenList.filter(t => {
      const s = t.symbol || '', n = t.name || '';
      const alreadyCG = cgStatsMap.has(low(s)) || cgStatsMap.has(low(n));
      return !alreadyCG && (s.toLowerCase().includes(q) || n.toLowerCase().includes(q));
    });

    const inchScored = inchMatches.map(t => {
      const startBonus = ((t.symbol && t.symbol.toLowerCase().startsWith(q)) || (t.name && t.name.toLowerCase().startsWith(q))) ? 1e10 : 0;
      return { t, stats: null, score: startBonus };
    });

    const merged = cgScored.sort((a,b)=> b.score - a.score).concat(inchScored.sort((a,b)=> b.score - a.score)).slice(0,12);
    if (!merged.length) { box.style.display='none'; return; }

    for (const s of merged) {
      const tk = s.t;
      const stats = s.stats || { change24h: null, logo: tk.logoURI || '' };
      const price = (stats && stats.price) ? stats.price : await getTokenPriceUSD(tk.address, tk.decimals);
      const node = makeSuggestionItem(tk, { change24h: stats.change24h ?? null, logo: tk.logoURI || '' }, price);
      node.addEventListener('click', ()=>{ applyTokenSelection(side, tk); box.style.display='none'; fetchBothPrices(); updateQuoteDebounced(); });
      box.appendChild(node);
    }
    box.style.display='block';
  }
}

setupAutocomplete('fromToken','fromSuggestions','from');
setupAutocomplete('toToken','toSuggestions','to');

/* Apply selected token (normalizes address, sets logo, decimals) */
function applyTokenSelection(side, tokenObj){
  if (!tokenObj) return;
  const input = (side === 'from') ? $('fromToken') : $('toToken');
  const logo = (side === 'from') ? $('fromLogo' ) : $('toLogo');
  const addrLower = tokenObj.address ? low(tokenObj.address) : undefined;
  input.value = tokenObj.symbol || tokenObj.name || (addrLower ? addrLower.slice(0,8) : '');
  if (addrLower) input.dataset.address = addrLower;
  input.dataset.decimals = tokenObj.decimals || 18;
  if (tokenObj.logoURI) { logo.src = tokenObj.logoURI; logo.style.display = 'inline-block'; }
  else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'inline-block'; }
  if (addrLower) {
    tokenMap.set(addrLower, Object.assign({}, tokenObj, { address: addrLower }));
    if (!tokenList.find(t => t.address === addrLower)) tokenList.push(Object.assign({}, tokenObj, { address: addrLower }));
  }
  // immediate price fetch and quote update
  fetchPriceForToken(addrLower || tokenObj.address, tokenObj.decimals, side);
  updateQuoteDebounced();
}

/* show/hide spinner */
function showSpinner(which, show = true) {
  const el = (which === 'from') ? $('fromSpinner') : $('toSpinner');
  if (!el) return;
  el.classList.toggle('visible', !!show);
}

/* fetch price and show USD with improved layout */
async function fetchPriceForToken(address, decimals, side){
  try {
    if (!address) {
      const usdElText = (side === 'from') ? $('fromUsdText') : $('toUsdText');
      usdElText.innerHTML = '≈ $—';
      return;
    }
    showSpinner(side, true);
    const price = await getTokenPriceUSD(address, decimals);
    const usdElText = (side === 'from') ? $('fromUsdText') : $('toUsdText');
    const amtEl = (side === 'from') ? $('fromAmount') : $('toAmount');
    const amtRaw = amtEl ? amtEl.value : '';
    const amt = (typeof amtRaw === 'string' && amtRaw.trim() === '') ? null : Number(amtRaw);
    // if user typed amount -> show total and per-token second line
    if (price != null && amt !== null && !Number.isNaN(amt)) {
      const total = Number(price) * amt;
      usdElText.innerHTML = `<div style="font-size:11px;opacity:0.85">≈ ${formatUSD(total)}</div><div style="margin-top:4px;font-weight:600;font-size:12px;opacity:0.95">${formatUSD(price)} / unit</div>`;
    } else if (price != null) {
      usdElText.innerHTML = `<div style="font-size:11px;opacity:0.85">≈ ${formatUSD(price)}</div><div style="margin-top:4px;font-weight:600;font-size:12px;opacity:0.95">per unit</div>`;
    } else {
      usdElText.innerHTML = '≈ $—';
    }
  } catch(e){ console.warn('fetchPriceForToken error', e); }
  finally { showSpinner(side, false); }
}

/* fetch both USD displays */
async function fetchBothPrices(){
  const fAddr = low($('fromToken').dataset.address || '');
  const tAddr = low($('toToken').dataset.address || '');
  const fDec = Number($('fromToken').dataset.decimals || 18);
  const tDec = Number($('toToken').dataset.decimals || 18);
  await Promise.all([
    fAddr ? fetchPriceForToken(fAddr, fDec, 'from') : Promise.resolve(),
    tAddr ? fetchPriceForToken(tAddr, tDec, 'to') : Promise.resolve()
  ]);
}

/* resolve token inputs (if user typed symbol/name instead of selecting) */
function resolveTokenInputsIfNeeded() {
  // helper to resolve an input element if it lacks dataset.address
  const tryResolve = (inputEl) => {
    const val = (inputEl.value || '').trim();
    if (!val || inputEl.dataset.address) return;
    const q = val.toLowerCase();
    // try exact symbol match first
    let found = tokenList.find(t => t.symbol && t.symbol.toLowerCase() === q);
    if (!found) {
      // try exact name match
      found = tokenList.find(t => t.name && t.name.toLowerCase() === q);
    }
    if (!found) {
      // try startsWith symbol
      found = tokenList.find(t => t.symbol && t.symbol.toLowerCase().startsWith(q));
    }
    if (found) {
      inputEl.dataset.address = found.address;
      inputEl.dataset.decimals = found.decimals || 18;
      const logo = (inputEl.id === 'fromToken') ? $('fromLogo') : $('toLogo');
      if (found.logoURI) { logo.src = found.logoURI; logo.style.display = 'inline-block'; }
      else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'inline-block'; }
    }
  };
  tryResolve($('fromToken'));
  tryResolve($('toToken'));
}

/* QUOTE logic: using 1inch to compute toAmount (live) */
let quoteTimer = null;
function updateQuoteDebounced(){ clearTimeout(quoteTimer); quoteTimer = setTimeout(()=> updateQuote(), 150); }

async function updateQuote(){
  try {
    // try to resolve typed symbols to addresses (Polygon-only tokenList)
    resolveTokenInputsIfNeeded();

    const fromAddr = low($('fromToken').dataset.address || '');
    const toAddr = low($('toToken').dataset.address || '');
    const amount = $('fromAmount').value;
    if (!fromAddr || !toAddr || !amount) { $('toAmount').value = ''; await fetchBothPrices(); return; }

    const fromDecimals = Number($('fromToken').dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const toDecimals = Number($('toToken').dataset.decimals || tokenMap.get(toAddr)?.decimals || 18);

    // parse carefully
    const parsed = ethers.utils.parseUnits(String(amount), fromDecimals).toString();
    const quoteUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${parsed}`;
    const r = await fetchWithTimeout(quoteUrl, {}, 5000);
    if (!r.ok) { $('toAmount').value = ''; await fetchBothPrices(); return; }
    const j = await r.json();
    if (j && j.toTokenAmount) {
      const formattedTo = ethers.utils.formatUnits(ethers.BigNumber.from(j.toTokenAmount), toDecimals);
      $('toAmount').value = formattedTo;
    } else {
      $('toAmount').value = '';
    }

    // update USD displays after we set toAmount
    await fetchBothPrices();
  } catch (e) {
    console.error('updateQuote error', e);
    $('toAmount').value = '';
    await fetchBothPrices();
  }
}

/* live update when typing amount */
$('fromAmount').addEventListener('input', updateQuoteDebounced);

/* paste address behavior (from/to inputs) */
document.querySelectorAll('.input-box input[type="text"]').forEach(inp=>{
  inp.addEventListener('paste', (ev)=>{
    const txt = (ev.clipboardData || window.clipboardData).getData('text').trim();
    if (isAddress(txt)) {
      setTimeout(async ()=> {
        inp.dataset.address = low(txt);
        let info = tokenMap.get(low(txt)) || await fetchOnchainTokenInfo(txt);
        if (info) {
          inp.dataset.decimals = info.decimals || 18;
          inp.value = info.symbol || info.name || txt.slice(0,8);
          tokenMap.set(info.address, info);
          const logo = (inp.id === 'fromToken') ? $('fromLogo') : $('toLogo');
          if (info.logoURI) { logo.src = info.logoURI; logo.style.display = 'inline-block'; }
          else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'inline-block'; }
          // fetch both prices & update quote
          fetchBothPrices();
          updateQuoteDebounced();
        }
      }, 10);
    }
  });
});

/* SWAP flow (unchanged main behavior; uses 1inch swap) */
async function ensureApprovalAndSwap(){
  try {
    await connectWallet();
    const fromInput = $('fromToken'), toInput = $('toToken');
    const amountInput = $('fromAmount').value;
    const slippage = $('slippage')?.value || 1;
    if (!fromInput.dataset.address || !toInput.dataset.address || !amountInput) { alert('Fill both tokens and amount'); return; }

    const fromAddr = low(fromInput.dataset.address);
    const toAddr = low(toInput.dataset.address);
    const fromDecimals = Number(fromInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const parsedAmount = ethers.utils.parseUnits(String(amountInput), fromDecimals).toString();

    if (fromAddr !== MATIC_ADDR) {
      const allowanceUrl = `${ONEINCH_BASE}/approve/allowance?tokenAddress=${fromAddr}&walletAddress=${signerAddress}`;
      const ar = await fetchWithTimeout(allowanceUrl, {}, 3000);
      const aj = await ar.json();
      const allowance = aj.allowance ? ethers.BigNumber.from(aj.allowance) : ethers.BigNumber.from('0');
      if (allowance.lt(ethers.BigNumber.from(parsedAmount))) {
        const aprUrl = `${ONEINCH_BASE}/approve/transaction?tokenAddress=${fromAddr}`;
        const aprRes = await fetchWithTimeout(aprUrl, {}, 3000);
        const aprJson = await aprRes.json();
        if (!aprJson || !aprJson.data) throw new Error('Approve data unavailable');
        const txReq = { to: aprJson.to, data: aprJson.data, value: aprJson.value ? ethers.BigNumber.from(aprJson.value) : undefined };
        const sent = await signer.sendTransaction(txReq);
        alert('Approve sent: ' + sent.hash);
        await sent.wait();
      }
    }

    const swapUrl = `${ONEINCH_BASE}/swap?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${parsedAmount}&fromAddress=${signerAddress}&slippage=${slippage}`;
    const sr = await fetchWithTimeout(swapUrl, {}, 5000);
    const sj = await sr.json();
    if (!sj || !sj.tx) { console.error('swap build failed', sj); alert('Swap build failed'); return; }
    const txReq = sj.tx;
    const sentSwap = await signer.sendTransaction(txReq);
    alert('Swap sent: ' + sentSwap.hash);
  } catch (e) {
    console.error('swap error', e);
    alert('Swap failed: ' + (e.message || e));
  }
}
$('swapBtn').addEventListener('click', ensureApprovalAndSwap);

/* WALLET connect (improved detection) */
async function connectWallet(){
  if (walletConnected && signer) return;
  try {
    if (window.ethereum && window.ethereum.isMetaMask) {
      provider = new ethers.providers.Web3Provider(window.ethereum, "any");
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      signerAddress = await signer.getAddress();
      walletConnected = true; $('walletConnectBtn').textContent = signerAddress.slice(0,6) + '...' + signerAddress.slice(-4);
      return;
    }

    const WC_global = window.WalletConnectProvider || (window.WalletConnectProvider && window.WalletConnectProvider.default) || null;
    if (!WC_global) { alert('WalletConnect library not loaded. Please open in a browser that allows external scripts or use MetaMask.'); throw new Error('WC library missing'); }

    const WcCtor = (typeof WC_global === 'function') ? WC_global : (WC_global.default || WC_global);
    const wcProvider = new WcCtor({ rpc: { [CHAIN_ID]: FALLBACK_RPC }, chainId: CHAIN_ID, qrcode: true });

    await wcProvider.enable();
    provider = new ethers.providers.Web3Provider(wcProvider, "any");
    signer = provider.getSigner();
    signerAddress = await signer.getAddress();
    walletConnected = true; $('walletConnectBtn').textContent = signerAddress.slice(0,6) + '...' + signerAddress.slice(-4);

    if (wcProvider.on) {
      wcProvider.on("disconnect", ()=> {
        walletConnected = false; provider = null; signer = null; signerAddress = null;
        $('walletConnectBtn').textContent = 'Connect Wallet';
      });
    }
  } catch(e){ console.error('connectWallet error', e); alert('Wallet connect failed: ' + (e.message||e)); throw e; }
}
$('walletConnectBtn').addEventListener('click', connectWallet);

/* SWAP tokens UI action */
function swapTokenFields(){
  const fToken = $('fromToken'), tToken = $('toToken');
  const fLogo = $('fromLogo'), tLogo = $('toLogo');
  const fAmount = $('fromAmount'), tAmount = $('toAmount');
  const fUsdText = $('fromUsdText'), tUsdText = $('toUsdText');

  // swap values
  const tmpVal = fToken.value; fToken.value = tToken.value; tToken.value = tmpVal;
  const tmpAddr = fToken.dataset.address; fToken.dataset.address = tToken.dataset.address; tToken.dataset.address = tmpAddr;
  const tmpDec = fToken.dataset.decimals; fToken.dataset.decimals = tToken.dataset.decimals; tToken.dataset.decimals = tmpDec;

  // logos
  const tmpSrc = fLogo.src; fLogo.src = tLogo.src; tLogo.src = tmpSrc;
  const tmpDisplay = fLogo.style.display; fLogo.style.display = tLogo.style.display; tLogo.style.display = tmpDisplay;

  // amounts & usd
  const tmpAmt = fAmount.value; fAmount.value = tAmount.value; tAmount.value = tmpAmt;
  const tmpUsd = fUsdText.innerHTML; fUsdText.innerHTML = tUsdText.innerHTML; tUsdText.innerHTML = tmpUsd;

  // refresh quote & prices
  updateQuoteDebounced();
  fetchBothPrices();
}
$('swapTokensBtn').addEventListener('click', swapTokenFields);

/* INIT: warm token lists */
(async function init(){
  await loadTokensAndVolumes();
})();
</script>
</body>
</html>
