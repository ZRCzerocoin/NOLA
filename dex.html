<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NOLA Exchange — Full</title>
<style>
/* ===== RESET & THEME ===== */
*{margin:0;padding:0;box-sizing:border-box;font-family:'Arial',sans-serif}
body{overflow-x:hidden;background:radial-gradient(circle at center,#0c0014,#1a002b 80%);color:#fff;scroll-behavior:smooth;min-height:100vh}
:root{
  --accent-1:#b445ff;--accent-2:#7013ff;
  --glass:rgba(255,255,255,0.05);--glass-2:rgba(255,255,255,0.03);
  --suggest-bg:rgba(25,0,50,0.98);
  --shadow:0 0 25px rgba(180,0,255,0.3);
  --container-max:480px;
}

/* NEBULA + PARTICLES */
body::before{content:'';position:fixed;left:-50%;top:-50%;width:200%;height:200%;background:radial-gradient(circle,rgba(150,0,255,0.12),transparent 60%);animation:nebulaMove 20s infinite alternate ease-in-out;z-index:-2}
@keyframes nebulaMove{0%{transform:translate(-10%,-10%)}100%{transform:translate(5%,5%)}}
.particle{position:absolute;width:2px;height:2px;background:#b445ff;border-radius:50%;opacity:0.8;animation:floatParticle linear infinite;z-index:-1}
@keyframes floatParticle{0%{transform:translateY(0) translateX(0);opacity:0.8}50%{transform:translateY(-50px) translateX(20px);opacity:0.4}100%{transform:translateY(0) translateX(0);opacity:0.8}}

/* TOP LOGO moved down to sit above section */
.logo{
  width:112px;height:auto;display:block;margin:0 auto;pointer-events:none;
  animation:logoGlow 5s ease-in-out infinite alternate,logoRotate 30s linear infinite;
  z-index:998;position:fixed;left:50%;top:18vh;transform:translateX(-50%);
}
@keyframes logoGlow{0%{filter:drop-shadow(0 0 12px #9c00ff)}50%{filter:drop-shadow(0 0 30px #d15fff)}100%{filter:drop-shadow(0 0 12px #9c00ff)}}
@keyframes logoRotate{0%{transform:translateX(-50%) rotateY(0deg)}100%{transform:translateX(-50%) rotateY(360deg)}}

/* SECTION WRAPPER - CENTER EVERYTHING */
.section-wrapper{min-height:100vh;display:flex;align-items:center;justify-content:center;gap:18px;padding:28px;position:relative;z-index:1}

/* CARD */
.container{width:90%;max-width:var(--container-max);margin:0;background:var(--glass);border:1px solid rgba(255,255,255,0.08);border-radius:25px;padding:22px;backdrop-filter:blur(18px);box-shadow:var(--shadow);animation:cardIn 800ms ease;position:relative}
@keyframes cardIn{from{opacity:0;transform:translateY(18px)}to{opacity:1;transform:translateY(0)}}
h2{text-align:center;font-size:26px;font-weight:600;margin-bottom:14px;color:#e0b3ff;text-shadow:0 0 8px #b445ff}

/* UNIFIED ROW - compact "thin bar" look */
.input-box{margin-top:14px;padding:8px 10px;background:rgba(255,255,255,0.03);border-radius:10px;border:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;gap:10px;position:relative;box-shadow:0 6px 16px rgba(150,0,255,0.04)}
.input-box .left{display:flex;align-items:center;gap:8px;min-width:0;flex:1}

/* chosen token icon shape: not circular (rounded rect) */
.token-icon{width:40px;height:30px;border-radius:8px;background:transparent;display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;position:relative;border:1px solid rgba(255,255,255,0.05);z-index:5}
.token-icon img{width:100%;height:100%;object-fit:cover;display:block;border-radius:6px;z-index:6}

/* suggestion list images remain circular */
.suggestion-left img{width:28px;height:28px;border-radius:50%;object-fit:cover}

/* chip */
.token-chip{position:absolute;right:-8px;bottom:-8px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));padding:3px 7px;border-radius:999px;font-weight:800;font-size:10px;color:#fff;box-shadow:0 8px 22px rgba(180,68,255,0.12),inset 0 -3px 8px rgba(0,0,0,0.12);display:none;white-space:nowrap;transform:translate(6px,6px);z-index:7}
.input-box.has-token .token-chip{display:inline-flex}

/* token info (symbol + 24h/12h change) - placed neatly next to icon */
.token-info{display:flex;flex-direction:column;gap:2px;min-width:0;z-index:3}
.token-symbol{font-weight:800;font-size:13px}
.token-change{font-size:12px;opacity:0.9}

/* INPUT BLOCK (single visible text input per row) */
.input-field{display:flex;flex-direction:column;min-width:0;width:100%}
.input-field input[type="text"]{padding:8px 10px;border-radius:8px;border:none;background:transparent;color:#fff;width:100%;outline:none;font-size:14px}
.input-amount{margin-left:8px;min-width:120px}
.input-amount input{width:100%;padding:8px 10px;border-radius:8px;border:none;background:rgba(255,255,255,0.03);color:#fff;font-size:14px;outline:none}

/* small price area under amount/estimate - align to right */
.price-small{display:flex;flex-direction:column;align-items:flex-end;margin-left:auto;margin-top:6px;min-width:120px;z-index:2}
.price-small .price-usd{font-size:12px;opacity:0.85}
.price-small .price-unit{font-size:12px;opacity:0.65}

/* SUGGESTIONS: COMPACT & STYLISH */
.suggestions{position:absolute;top:68px;left:12px;right:12px;background:var(--suggest-bg);border-radius:12px;padding:6px;max-height:240px;overflow:auto;display:none;z-index:220;box-shadow:0 10px 30px rgba(120,0,255,0.08)}
.suggestion-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:10px;cursor:pointer;justify-content:space-between}
.suggestion-item:hover{background:linear-gradient(90deg, rgba(180,68,255,0.06), rgba(112,19,255,0.04))}
.suggestion-left{display:flex;align-items:center;gap:10px;min-width:0}
.suggestion-main{display:flex;flex-direction:column;min-width:0}
.suggestion-symbol{font-weight:700;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.suggestion-name{font-size:12px;opacity:0.8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.suggestion-price-pill{min-width:70px;text-align:right;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);font-weight:700;font-size:12px}

/* SWAP OUTSIDE CONTROL moved into controls area */
.swap-outside{
  width:46px;height:46px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);box-shadow:0 8px 20px rgba(120,0,255,0.06);cursor:pointer;font-size:20px;color:#fff;transition:transform 160ms ease,box-shadow 160ms ease;backdrop-filter:blur(6px)}
.swap-outside:hover{transform:translateY(-4px) rotate(-10deg)}

/* SLIPPAGE THEME - minimal, placed on right side of controls */
.slippage-min{appearance:none;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);color:#fff;border:1px solid rgba(255,255,255,0.05);font-weight:700;font-size:13px}

/* tiny glassy tooltip / toast */
.toast{position:relative;display:inline-block;padding:12px 18px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.04),rgba(255,255,255,0.02));backdrop-filter:blur(8px);box-shadow:0 10px 40px rgba(0,0,0,0.5);color:#fff;font-weight:700;margin-top:8px}

/* ELECTRIC PILL SWAP BUTTON */
.electric-btn{display:inline-block;border:0;background:transparent;padding:0;cursor:pointer}
.electric-pill{
position:relative;display:inline-flex;align-items:center;gap:12px;padding:10px 26px;border-radius:999px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));box-shadow:0 12px 36px rgba(180,68,255,0.18);color:#fff;font-weight:800;font-size:15px;border:none;outline:none;overflow:hidden;transition:transform 140ms ease,box-shadow 140ms ease;}
.electric-pill:active{transform:translateY(-1px) scale(.997)}
.electric-pill .sweep{position:absolute;left:-30%;top:-10%;width:40%;height:120%;background:linear-gradient(90deg,rgba(255,255,255,0.5),rgba(255,255,255,0.12),rgba(255,255,255,0.02));transform:skewX(-18deg);opacity:0.18;filter:blur(10px);border-radius:12px;animation:slideSweep 2.1s linear infinite}
@keyframes slideSweep{0%{transform:translateX(-160%) skewX(-18deg)}50%{transform:translateX(120%) skewX(-18deg)}100%{transform:translateX(360%) skewX(-18deg)}}
.electric-pill .label{position:relative;z-index:2;pointer-events:none}
.electric-pill .icon{width:26px;height:26px;border-radius:999px;background:rgba(255,255,255,0.08);display:inline-flex;align-items:center;justify-content:center;font-weight:900;z-index:2;box-shadow:inset 0 -4px 8px rgba(0,0,0,0.18)}

/* Connected state (lights up) */
.electric-pill.connected{box-shadow:0 20px 60px rgba(180,68,255,0.28),0 0 60px rgba(180,68,255,0.12);transform:translateY(-2px)}
.electric-pill.connected .icon{background:linear-gradient(180deg,#fff,#f5e7ff);color:#3b0066}

/* SMALLER variant for the container's swap appearance */
.swap-row{display:flex;gap:12px;align-items:center}
.swap-row .electric-btn{flex:1}

/* TOP-RIGHT CONNECT */
.top-right-connect{position:fixed;right:18px;top:18px;z-index:70;display:flex;gap:10px;align-items:center}
.addr-chip{padding:8px 12px;border-radius:12px;background:rgba(255,255,255,0.03);font-weight:700;display:none}
.connect-floating{background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#fff;padding:10px 14px;border-radius:12px;border:none;cursor:pointer;font-weight:800;box-shadow:0 10px 30px rgba(106,0,255,0.12)}

/* FOOTER */
.footer{position:fixed;left:0;right:0;bottom:12px;display:flex;flex-direction:column;gap:6px;align-items:center;justify-content:center;z-index:40;color:rgba(255,255,255,0.75);font-size:13px}
.footer a{color:rgba(215,165,255,0.95);text-decoration:none;font-weight:700;margin-left:8px}

/* SMALL SCREEN POLISH */
@media(max-width:720px){
  .section-wrapper{padding:18px;gap:12px;flex-direction:column-reverse}
  .container{width:100%;max-width:520px}
  .input-box .token-chip{font-size:10px;padding:3px 6px;right:-4px;bottom:-4px}
  .logo{top:12vh;width:88px}
}
</style>
</head>
<body>

<!-- particles will be created by script -->
<!-- logo (inline SVG fallback) -->
<img id="logoFloat" class="logo" src="data:image/svg+xml;utf8,<?xml version='1.0' encoding='utf-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'><defs><linearGradient id='g' x1='0' x2='1'><stop offset='0' stop-color='%23b445ff'/><stop offset='1' stop-color='%237013ff'/></linearGradient></defs><rect rx='28' ry='28' width='200' height='200' fill='url(%23g)'/><text x='50%' y='54%' font-size='56' fill='white' font-family='Arial' font-weight='700' text-anchor='middle' dominant-baseline='middle'>N</text></svg>" alt="NOLA Logo">

<!-- top-right connect -->
<div class="top-right-connect">
  <div id="addrChip" class="addr-chip"></div>
  <button id="connectFloating" class="connect-floating">Connect Wallet</button>
</div>

<!-- SECTION WRAPPER centers card and swap control -->
<div class="section-wrapper">

  <div class="container" role="main" aria-label="NOLA Exchange">
    <h2>NOLA Exchange</h2>

    <!-- FROM -->
    <div class="input-box" id="fromBox" style="position:relative;">
      <div class="left">
        <div class="token-icon" id="fromIcon">
          <img id="fromLogo" src="" alt="" style="display:none">
          <span class="token-chip" id="fromChip" style="display:none">---</span>
        </div>

        <!-- token info: symbol + change (percent + timeframe) -->
        <div class="token-info">
          <div class="token-symbol" id="fromSymbol">---</div>
          <div class="token-change" id="fromChange" style="display:none">+0.00% (24h)</div>
        </div>

        <div class="input-field">
          <input id="fromToken" placeholder="Token symbol or contract (paste address too)" style="padding:8px 10px;border-radius:8px;border:none;background:transparent;color:#fff;width:100%">
        </div>

        <div class="input-amount" style="min-width:120px;">
          <input id="fromAmount" placeholder="Amount" type="number" step="any">
        </div>

        <!-- small price area under amount (aligned to right; won't overlap icon) -->
        <div class="price-small">
          <div id="fromUsdSmall" class="price-usd" style="display:none">≈ $—</div>
          <div id="fromUnitSmall" class="price-unit" style="display:none">— / unit</div>
        </div>

      </div>
      <div class="suggestions" id="fromSuggestions" data-side="from"></div>
    </div>

    <!-- TO -->
    <div class="input-box" id="toBox" style="position:relative;margin-top:12px;">
      <div class="left">
        <div class="token-icon" id="toIcon">
          <img id="toLogo" src="" alt="" style="display:none">
          <span class="token-chip" id="toChip" style="display:none">---</span>
        </div>

        <!-- token info: symbol + change (percent + timeframe) -->
        <div class="token-info">
          <div class="token-symbol" id="toSymbol">---</div>
          <div class="token-change" id="toChange" style="display:none">+0.00% (24h)</div>
        </div>

        <div class="input-field">
          <input id="toToken" placeholder="Token symbol or contract (paste address too)" style="padding:8px 10px;border-radius:8px;border:none;background:transparent;color:#fff;width:100%">
        </div>

        <div class="input-amount" style="min-width:120px;">
          <input id="toAmount" placeholder="Estimate" readonly>
        </div>

        <!-- small price area under estimate -->
        <div class="price-small">
          <div id="toUsdSmall" class="price-usd" style="display:none">≈ $—</div>
          <div id="toUnitSmall" class="price-unit" style="display:none">— / unit</div>
        </div>

      </div>
      <div class="suggestions" id="toSuggestions" data-side="to"></div>
    </div>

    <!-- CONTROLS: slippage minimal on right, swap icon moved here -->
    <div class="controls" style="margin-top:14px;display:flex;align-items:center;gap:12px;">
      <div style="flex:1;display:flex;align-items:center;gap:10px">
        <div id="swapOutside" class="swap-outside" title="Swap From ↔ To">⇅</div>
      </div>

      <div style="display:flex;align-items:center;gap:10px;">
        <select id="slippage" class="slippage-min" title="Select slippage">
          <option value="0.1">0.1%</option><option value="0.5">0.5%</option><option value="1" selected>1%</option><option value="2">2%</option><option value="3">3%</option>
        </select>
      </div>
    </div>

    <div class="swap-row" style="margin-top:14px">
      <!-- new electric pill swap button (id kept as swapBtn) -->
      <button id="swapBtn" class="electric-btn" title="Swap">
        <span class="electric-pill" role="button" aria-pressed="false">
          <span class="sweep" aria-hidden="true"></span>
          <span class="icon">⇄</span>
          <span class="label">Swap</span>
        </span>
      </button>
    </div>
  </div>
</div>

<!-- toast container -->
<div id="toastRoot" style="pointer-events:none;position:fixed;right:18px;bottom:90px;z-index:9999"></div>

<!-- footer -->
<div class="footer">
  <div>© 2025 NOLA — All rights reserved</div>
  <div><a href="PrivacyTerms.html" id="privacyTerms">Privacy & Terms</a> • <a href="#" id="xLink">X</a> <a href="#" id="tgLink">Telegram</a> <a href="#" id="siteLink">Website</a></div>
</div>

<!-- LIBS -->
<script src="https://cdn.jsdelivr.net/npm/ethers/dist/ethers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
<script src="https://unpkg.com/@web3modal/html@2.1.1/dist/index.js"></script>
<script src="https://unpkg.com/@walletconnect/web3modal@2.6.4/dist/w3m.min.js"></script>

<script>
/* ================= PARTICLES */
(function createParticles(){ for(let i=0;i<60;i++){ const p=document.createElement('div'); p.className='particle'; p.style.top=(Math.random()*100)+'%'; p.style.left=(Math.random()*100)+'%'; p.style.width=(Math.random()*3+1)+'px'; p.style.height=(Math.random()*3+1)+'px'; p.style.animationDuration=(Math.random()*10+5)+'s'; document.body.appendChild(p); }})();

/* ================= CONFIG & STATE */
const CHAIN_ID = 137;
const ONEINCH_BASE = `https://api.1inch.io/v5.0/${CHAIN_ID}`;
const ZEROX_BASE = 'https://polygon.api.0x.org';
const COINGECKO_CHAIN = 'polygon-pos';
const FALLBACK_RPC = "https://polygon-rpc.com";
const USDC_ADDR = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const WETH_ADDR = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619';
const MATIC_ADDR = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const WALLETCONNECT_PROJECT_ID = "6557a92e3698182727669d41cbeb95a1";

/* ========== USER-SUPPLIED 0x API KEY ========== */
/* You provided: 099490ac-79a1-4416-a088-df38b6e0c384 */
const ZEROX_API_KEY = '099490ac-79a1-4416-a088-df38b6e0c384';

/* ========== FEE SETTINGS ========== */
/* Fee percentage (0.001% as requested => 0.00001 decimal) */
let PLATFORM_FEE_PERCENT = 0.00001; // 0.001% (change if you'd like; extremely low already)
const FEE_RECIPIENT = '0xYOUR_FEE_ADDRESS_HERE'; // <-- replace with your address

/* ========== CACHE & INTERVALS ========== */
let tokenList = [];
let tokenMap = new Map();
let cgStatsMap = new Map();
const priceCache = new Map();
const suggestionCache = new Map();
const ACTIVE_PRICE_ADDRS = new Set();
/* TTL and refresh now 10s per request as requested */
const PRICE_TTL = 10000; // 10s TTL
const SUGGEST_LIMIT = 12;
const DARK_SVG_PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36"><rect width="100%" height="100%" rx="6" ry="6" fill="#151225"/></svg>`);

/* ================= DOM REFS */
const $ = id => document.getElementById(id);
const fromTokenInput = $('fromToken'), toTokenInput = $('toToken');
const fromAmountEl = $('fromAmount'), toAmountEl = $('toAmount');
const fromUsdSmall = $('fromUsdSmall'), toUsdSmall = $('toUsdSmall');
const fromUnitSmall = $('fromUnitSmall'), toUnitSmall = $('toUnitSmall');
const fromLogo = $('fromLogo'), toLogo = $('toLogo');
const fromChip = $('fromChip'), toChip = $('toChip');
const fromSuggestions = $('fromSuggestions'), toSuggestions = $('toSuggestions');
const swapOutside = $('swapOutside'), swapBtn = $('swapBtn');
const fromBox = $('fromBox'), toBox = $('toBox');
const connectFloating = $('connectFloating'), addrChip = $('addrChip');
const slippageSel = $('slippage');
const fromChangeEl = $('fromChange'), toChangeEl = $('toChange');

/* ================= HELPERS */
const isAddress = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
const low = s => (s||'').toLowerCase();
const nowTs = ()=> Date.now();
function formatUSD(v){ if (v===null||v===undefined||!Number.isFinite(v)) return '—'; const n=Number(v); const opts={style:'currency',currency:'USD',maximumFractionDigits:2,minimumFractionDigits:2}; if(Math.abs(n)>0&&Math.abs(n)<0.01){opts.maximumFractionDigits=6;opts.minimumFractionDigits=4;} return new Intl.NumberFormat('en-US',opts).format(n); }
function fetchWithTimeout(url,opts={},ms=5000){ const controller=new AbortController(); const id=setTimeout(()=>controller.abort(),ms); const init=Object.assign({},opts,{signal:controller.signal}); return fetch(url,init).finally(()=>clearTimeout(id)); }
async function fetchJson(url,opts){ const r = await fetch(url,opts); if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); }

/* quick glassy toast */
function showToast(msg,ttl=3500){
  const root = $('toastRoot');
  const el=document.createElement('div');
  el.className='toast';
  el.textContent=msg;
  el.style.pointerEvents='auto';
  root.appendChild(el);
  setTimeout(()=>{ el.style.opacity=1; },10);
  setTimeout(()=>{ el.style.transition='opacity 300ms'; el.style.opacity=0; setTimeout(()=>el.remove(),300); },ttl);
}

/* ================= LOAD TOKENS & COINGECKO MARKETS */
async function loadTokensAndMarkets(){
  try {
    const r = await fetch('https://tokens.coingecko.com/polygon-pos/all.json');
    const j = await r.json();
    tokenList = (j.tokens||[]).map(t => ({ address: low(t.address), symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||t.logo||'' }));
    tokenList.forEach(t => tokenMap.set(t.address, t));
    if (!tokenMap.has(MATIC_ADDR)) tokenMap.set(MATIC_ADDR, { address: MATIC_ADDR, symbol:'MATIC', name:'Polygon', decimals:18, logoURI: '' });

    try {
      const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`;
      const rm = await fetchWithTimeout(marketsUrl, {}, 5000);
      const jm = await rm.json();
      jm.forEach(c => {
        const sym = low(c.symbol||''), name = low(c.name||'');
        const stat = { price: (typeof c.current_price === 'number' ? c.current_price : null), change24h: (typeof c.price_change_percentage_24h === 'number' ? c.price_change_percentage_24h : null), volume24h: (typeof c.total_volume === 'number' ? c.total_volume : 0), image: c.image||'', volume12h: null, timeframe:'24h' };
        if (sym) cgStatsMap.set(sym, stat);
        if (name) cgStatsMap.set(name, stat);
      });
    } catch(e){ console.warn('CoinGecko markets failed', e); }

    try {
      const r1 = await fetch(`${ONEINCH_BASE}/tokens`);
      const j1 = await r1.json();
      if (j1 && j1.tokens) {
        Object.values(j1.tokens).forEach(t => {
          const addr = low(t.address||'');
          if (!addr) return;
          if (tokenMap.has(addr)) return;
          const obj = { address: addr, symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||'' };
          tokenList.push(obj); tokenMap.set(addr, obj);
        });
      }
    } catch(e){ /* ignore */ }

    // dedupe
    const seen = new Set();
    tokenList = tokenList.filter(t => { if(!t||!t.address) return false; if(seen.has(t.address)) return false; seen.add(t.address); return true; });
    console.log('Loaded tokens:', tokenList.length);
  } catch(e){ console.error('loadTokensAndMarkets error', e); }
}
let tokensLoadedPromise = loadTokensAndMarkets();
async function ensureTokensLoaded(){ if (!tokensLoadedPromise) tokensLoadedPromise = loadTokensAndMarkets(); await tokensLoadedPromise; }

/* ================= PRICE SOURCES (priority: 0x -> CoinGecko -> 1inch) */
/* 0x price endpoint */
async function fetch0xPrice(addr, decimals=18){
  try {
    // 0x price expects token addresses or symbols; include API key header
    const sell = addr;
    const url = `${ZEROX_BASE}/swap/v1/price?sellToken=${encodeURIComponent(sell)}&buyToken=${encodeURIComponent(USDC_ADDR)}&sellAmount=${ethers.utils.parseUnits('1', decimals).toString()}`;
    const res = await fetch(url, { headers: { '0x-api-key': ZEROX_API_KEY }});
    if (!res.ok) throw new Error('0x price non-ok');
    const j = await res.json();
    // 0x returns pricePerUnit in buyAmount/sellAmount. Normalize:
    if (j && (j.price || j.buyAmount)) {
      // If price field exists, use it. Otherwise compute.
      if (typeof j.price === 'number') return { price: j.price, change:null, timeframe:'12h' };
      if (j.buyAmount && j.sellAmount) {
        const buy = Number(ethers.utils.formatUnits(ethers.BigNumber.from(j.buyAmount), 6)); // USDC decimals
        const sell = Number(ethers.utils.formatUnits(ethers.BigNumber.from(j.sellAmount), decimals));
        const price = buy / sell;
        return { price, change:null, timeframe:'12h' };
      }
    }
    throw new Error('0x price no price');
  } catch(e){ throw e; }
}
/* 1inch quote-based price */
async function fetch1InchSimplePrice(addr, decimals=18){
  try {
    const amountBN = ethers.BigNumber.from(10).pow(decimals);
    const qUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${addr}&toTokenAddress=${USDC_ADDR}&amount=${amountBN.toString()}`;
    const res = await fetchWithTimeout(qUrl,{},3000);
    if (!res.ok) throw new Error('1inch non-ok');
    const j = await res.json();
    if (j && j.toTokenAmount) {
      const usdcAmountBN = ethers.BigNumber.from(j.toTokenAmount);
      const usdc = Number(ethers.utils.formatUnits(usdcAmountBN, j.toToken?.decimals ?? 6));
      if (Number.isFinite(usdc) && usdc > 0) return usdc;
    }
    throw new Error('1inch no price');
  } catch(e){ throw e; }
}
/* CoinGecko contract price */
async function fetchCoingeckoContractPrice(addr){
  try {
    const url = `https://api.coingecko.com/api/v3/coins/${COINGECKO_CHAIN}/contract/${addr}`;
    const res = await fetchWithTimeout(url,{},3000);
    if (!res.ok) throw new Error('cg contract non-ok');
    const j = await res.json();
    const price = j?.market_data?.current_price?.usd;
    const change = j?.market_data?.price_change_percentage_24h;
    const timeframe = '24h';
    if (typeof price === 'number' && price > 0) return { price, change, timeframe };
    throw new Error('cg no price');
  } catch(e){ throw e; }
}

async function getTokenPriceUSD(address, decimals=18){
  if (!address) return null;
  const addr = low(address);
  const cached = priceCache.get(addr);
  if (cached && (nowTs() - cached.ts) < PRICE_TTL) {
    if (cached.price === null || cached.price === 0 || (Math.abs(cached.price) < 1e-18 && cached.price !== null)) {
    } else {
      return cached.price;
    }
  }

  // Try 0x price first (fast), then Coingecko, then 1inch
  try {
    const p0 = await fetch0xPrice(addr, decimals);
    if (p0 && p0.price && Number.isFinite(p0.price) && p0.price > 0) { priceCache.set(addr, {price:p0.price, ts:nowTs(), change:p0.change, timeframe:p0.timeframe}); return p0.price; }
  } catch(_) {}

  try {
    const cg = await fetchCoingeckoContractPrice(addr);
    if (cg && cg.price && Number.isFinite(cg.price) && cg.price > 0) { priceCache.set(addr, {price:cg.price, ts:nowTs(), change:cg.change, timeframe:cg.timeframe}); return cg.price; }
  } catch(_) {}

  try {
    const v = await fetch1InchSimplePrice(addr, decimals);
    if (v && Number.isFinite(v) && v > 0) { priceCache.set(addr, {price:v, ts:nowTs()}); return v; }
  } catch(_) {}

  // fallback to cached mapped symbol from cgStatsMap
  try {
    const t = tokenMap.get(addr);
    if (t && t.symbol){
      const stat = cgStatsMap.get(low(t.symbol));
      if (stat && stat.price && Number.isFinite(stat.price) && stat.price > 0) { priceCache.set(addr, {price:stat.price, ts:nowTs()}); return stat.price; }
    }
  } catch(_) {}

  priceCache.set(addr, {price:null, ts:nowTs()});
  return null;
}

/* ================= SUGGESTION UI & PRIORITIZATION */
function makeSuggestionItem(tokenObj, stats, priceUSD){
  const row = document.createElement('div'); row.className='suggestion-item';
  const left = document.createElement('div'); left.className='suggestion-left';
  const img = document.createElement('img'); img.src = tokenObj.logoURI || (stats && stats.image) || DARK_SVG_PLACEHOLDER; img.onerror = ()=> img.src = DARK_SVG_PLACEHOLDER;
  img.style.width='28px'; img.style.height='28px'; img.style.borderRadius='50%';
  left.appendChild(img);
  const main = document.createElement('div'); main.className='suggestion-main';
  const sym = document.createElement('div'); sym.className='suggestion-symbol'; sym.textContent = tokenObj.symbol || (tokenObj.address?tokenObj.address.slice(0,6):'');
  const nm = document.createElement('div'); nm.className='suggestion-name'; nm.textContent = tokenObj.name || '';
  main.appendChild(sym); main.appendChild(nm);
  if (stats && (typeof stats.change24h === 'number' || typeof stats.change === 'number')) {
    const ch = document.createElement('div'); ch.style.fontSize='11px'; ch.style.marginTop='6px'; ch.style.opacity='0.9';
    const change = (typeof stats.change24h === 'number') ? stats.change24h : stats.change;
    const timeframe = stats.timeframe || '24h';
    ch.textContent = (change>=0?'+':'')+parseFloat(change||0).toFixed(2)+'% ('+timeframe+')';
    ch.style.color = change >= 0 ? '#9ef39e' : '#ff9e9e';
    main.appendChild(ch);
  }
  left.appendChild(main);
  row.appendChild(left);
  const right = document.createElement('div'); right.className='suggestion-price-pill';
  if (priceUSD != null && Number.isFinite(priceUSD)) right.textContent = formatUSD(priceUSD);
  else right.textContent = '—';
  row.appendChild(right);
  return row;
}

/* Ranking: use CG 24h volume primarily and 0x/1inch recency where available */
function showDefaultList(side){
  const box = (side === 'from') ? fromSuggestions : toSuggestions;
  box.innerHTML = '';
  const candidates = tokenList.filter(t => { const s = low(t.symbol), n = low(t.name); return cgStatsMap.has(s) || cgStatsMap.has(n); });
  const withStats = candidates.map(t => { const s = low(t.symbol), n = low(t.name); const stat = cgStatsMap.get(s) || cgStatsMap.get(n) || {price:null,change24h:null,volume24h:0,image:''}; return {t,stat}; });
  withStats.sort((a,b)=> (b.stat.volume24h||0) - (a.stat.volume24h||0));
  const top = withStats.slice(0, Math.min(15, withStats.length));
  (async ()=>{
    for (const e of top){
      const tk = e.t, stats = e.stat;
      let price = stats.price ?? await getTokenPriceUSD(tk.address, tk.decimals);
      // ensure fallback
      if (!price) price = await getTokenPriceUSD(tk.address, tk.decimals);
      const node = makeSuggestionItem(tk, {change24h: stats.change24h ?? null, change: stats.change24h ?? null, timeframe:'24h', image: tk.logoURI || stats.image}, price);
      node.addEventListener('click', ()=>{ applyTokenSelection((side==='from')?'from':'to', tk); box.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd((side==='from')?fromTokenInput:toTokenInput); });
      box.appendChild(node);
    }
    box.style.display = top.length ? 'block' : 'none';
  })();
}

/* AUTOCOMPLETE SETUP */
function setupAutocomplete(inputEl, boxEl, side){
  let timer = null;
  inputEl.addEventListener('input', ()=>{ clearTimeout(timer); timer = setTimeout(()=> handle(inputEl.value.trim().toLowerCase()), 140); });
  inputEl.addEventListener('focus', ()=> { const q = inputEl.value.trim().toLowerCase(); if (!q) showDefaultList(side); else handle(q); placeCaretAtEnd(inputEl); });
  inputEl.addEventListener('blur', ()=> setTimeout(()=> { boxEl.style.display='none'; }, 160));

  async function handle(q){
    boxEl.innerHTML = ''; if (!q){ boxEl.style.display='none'; return; }
    if (isAddress(q)){
      let info = tokenMap.get(low(q));
      if (!info) info = await fetchOnchainTokenInfo(q);
      if (info){
        // stats bias: prefer cg 24h then 0x (12h)
        const stat = cgStatsMap.get(low(info.symbol)) || cgStatsMap.get(low(info.name)) || null;
        let price = stat?.price ?? null;
        if (!price){
          try { const p0 = await fetch0xPrice(info.address, info.decimals); if (p0 && p0.price) { price = p0.price; } } catch(e){}
        }
        if (!price) price = await getTokenPriceUSD(info.address, info.decimals);
        const node = makeSuggestionItem(info, {change24h: stat?.change24h ?? null, change: stat?.change24h ?? null, timeframe:'24h', image: info.logoURI}, price);
        node.addEventListener('click', ()=>{ applyTokenSelection(side, info); boxEl.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd(inputEl); });
        boxEl.appendChild(node); boxEl.style.display='block';
      }
      return;
    }

    if (suggestionCache.has(q)){ renderSuggestionsFromCache(q, side, boxEl); return; }
    await ensureTokensLoaded();

    const matches = tokenList.filter(t => {
      const s = t.symbol || '', n = t.name || '';
      return (s.toLowerCase().includes(q) || n.toLowerCase().includes(q));
    });

    const cgMatches = matches.filter(t => cgStatsMap.has(low(t.symbol)) || cgStatsMap.has(low(t.name)))
      .map(t => {
        const stats = cgStatsMap.get(low(t.symbol)) || cgStatsMap.get(low(t.name)) || {volume24h:0,volume12h:null,price:null,change24h:null,image:''};
        const startBonus = ((t.symbol && t.symbol.toLowerCase().startsWith(q)) || (t.name && t.name.toLowerCase().startsWith(q))) ? 1e12 : 0;
        const v24 = stats.volume24h || 0;
        const v12 = stats.volume12h || 0;
        const score = v24 + (v12 * 1.2) + startBonus;
        return {t, stats, score};
      });
    cgMatches.sort((a,b)=> b.score - a.score);

    const inchMatches = matches.filter(t => {
      const s = t.symbol || '', n = t.name || '';
      const hasCG = cgStatsMap.has(low(s)) || cgStatsMap.has(low(n));
      return !hasCG && (s.toLowerCase().includes(q) || n.toLowerCase().includes(q));
    }).map(t => { const startBonus = ((t.symbol && t.symbol.toLowerCase().startsWith(q)) || (t.name && t.name.toLowerCase().startsWith(q))) ? 1e10 : 0; return {t,stats:null,score:startBonus}; })
      .sort((a,b)=> b.score - a.score);

    const merged = cgMatches.concat(inchMatches).slice(0, SUGGEST_LIMIT);
    const cacheResult = merged.map(x => ({ address: x.t.address, symbol: x.t.symbol, name: x.t.name, logoURI: x.t.logoURI, score: x.score }));
    suggestionCache.set(q, cacheResult);

    for (const s of merged){
      const tk = s.t;
      const stats = s.stats || {change24h:null,image: tk.logoURI||''};
      (async ()=>{
        const price = (s.stats && s.stats.price) ? s.stats.price : await getTokenPriceUSD(tk.address, tk.decimals);
        const node = makeSuggestionItem(tk, {change24h: stats.change24h ?? null, change: stats.change24h ?? null, timeframe:'24h', image: tk.logoURI || ''}, price);
        node.addEventListener('click', ()=>{ applyTokenSelection(side, tk); boxEl.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd(inputEl); });
        boxEl.appendChild(node);
      })();
    }
    boxEl.style.display = merged.length ? 'block' : 'none';
  }
}
function renderSuggestionsFromCache(q, side, box){
  const cached = suggestionCache.get(q) || [];
  box.innerHTML = '';
  (async ()=>{
    for (const item of cached.slice(0,SUGGEST_LIMIT)){
      const tk = tokenMap.get(low(item.address)) || { address: item.address, symbol: item.symbol, name: item.name, logoURI: item.logoURI };
      const stats = cgStatsMap.get(low(tk.symbol)) || cgStatsMap.get(low(tk.name)) || null;
      const price = await getTokenPriceUSD(tk.address, tk.decimals || 18);
      const node = makeSuggestionItem(tk, {change24h: stats?.change24h ?? null, change: stats?.change24h ?? null, timeframe:'24h', image: tk.logoURI || stats?.image}, price);
      node.addEventListener('click', ()=>{ applyTokenSelection(side, tk); box.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd((side==='from')?fromTokenInput:toTokenInput); });
      box.appendChild(node);
    }
    box.style.display = cached.length ? 'block' : 'none';
  })();
}

/* attach autocomplete */
setupAutocomplete(fromTokenInput, fromSuggestions, 'from');
setupAutocomplete(toTokenInput, toSuggestions, 'to');

/* ================= SELECTION, USD DISPLAY, PASTE, RESOLVE ================= */
function applyTokenSelection(side, tokenObj){
  if (!tokenObj) return;
  const input = (side === 'from') ? fromTokenInput : toTokenInput;
  const logo = (side === 'from') ? fromLogo : toLogo;
  const chip = (side === 'from') ? fromChip : toChip;
  const box = (side === 'from') ? fromBox : toBox;
  input.value = tokenObj.symbol || tokenObj.name || '';
  if (tokenObj.address) input.dataset.address = low(tokenObj.address);
  input.dataset.decimals = tokenObj.decimals || 18;

  // preferred high quality icon: CoinGecko image if available
  const cgImg = (cgStatsMap.get(low(tokenObj.symbol)) || {}).image;
  if (cgImg) { logo.src = cgImg; logo.style.display = 'block'; } 
  else if (tokenObj.logoURI) { logo.src = tokenObj.logoURI; logo.style.display = 'block'; }
  else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'block'; }

  tokenMap.set(tokenObj.address, tokenObj);
  box.classList.add('has-token');
  ACTIVE_PRICE_ADDRS.add(low(tokenObj.address));
  // show small chip inside icon
  chip.textContent = tokenObj.symbol || tokenObj.name || '';
  chip.style.display = 'inline-flex';
  // ensure caret at end for fast typing
  focusAndPlaceCaretAtEnd(input);
  fetchPriceForToken(tokenObj.address, tokenObj.decimals || 18, side);

  // show 24h/12h change if available and show timeframe exactly
  try {
    const sym = (tokenObj.symbol||'').toLowerCase();
    const nm = (tokenObj.name||'').toLowerCase();
    const stat = cgStatsMap.get(sym) || cgStatsMap.get(nm) || null;
    if (stat && typeof stat.change24h === 'number') {
      const el = (side==='from')? fromChangeEl : toChangeEl;
      el.style.display = 'block';
      el.textContent = (stat.change24h >= 0 ? '+' : '') + stat.change24h.toFixed(2) + '% (24h)';
      el.style.color = stat.change24h >= 0 ? '#9ef39e' : '#ff9e9e';
    } else {
      // try 0x price-based change (we didn't store change but keep space for it)
      const el = (side==='from')? fromChangeEl : toChangeEl;
      el.style.display = 'none';
    }
  } catch(e){}
}
function clearTokenSelection(side){
  const box = (side === 'from') ? fromBox : toBox;
  box.classList.remove('has-token');
  box.style.removeProperty('--token-icon-bg');
  const chip = (side === 'from') ? fromChip : toChip;
  chip.style.display = 'none';
  const changeEl = (side === 'from') ? fromChangeEl : toChangeEl;
  if (changeEl) changeEl.style.display = 'none';
}

document.querySelectorAll('.input-box input[type="text"], .input-box input[type="number"]').forEach(inp=>{
  inp.addEventListener('paste', (ev)=>{
    const txt = (ev.clipboardData || window.clipboardData).getData('text').trim();
    if (isAddress(txt)) {
      setTimeout(async ()=> {
        inp.dataset.address = low(txt);
        let info = tokenMap.get(low(txt)) || await fetchOnchainTokenInfo(txt);
        if (info) {
          inp.dataset.decimals = info.decimals || 18;
          inp.value = info.symbol || info.name || txt.slice(0,8);
          tokenMap.set(info.address, info);
          const logo = (inp.id === 'fromToken') ? fromLogo : toLogo;
          const chip = (inp.id === 'fromToken') ? fromChip : toChip;
          const cgImg = (cgStatsMap.get(low(info.symbol)) || {}).image;
          if (cgImg) { logo.src = cgImg; logo.style.display = 'block'; } else if (info.logoURI) { logo.src = info.logoURI; logo.style.display = 'block'; } else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'block'; }
          const box = (inp.id === 'fromToken') ? fromBox : toBox;
          box.classList.add('has-token'); box.style.setProperty('--token-icon-bg', info.logoURI ? `url('${info.logoURI}')` : 'none');
          chip.textContent = info.symbol || info.name || '';
          chip.style.display = 'inline-flex';
          updateUsdVisibility();
          fetchBothPrices(); updateQuoteDebounced(); updateEstimate();
        }
      }, 10);
    }
  });
});

async function fetchOnchainTokenInfo(address){
  try {
    const addrL = low(address);
    if (tokenMap.has(addrL)) return tokenMap.get(addrL);
    const rpcProvider = new ethers.providers.JsonRpcProvider(FALLBACK_RPC);
    const abi = ["function symbol() view returns (string)","function name() view returns (string)","function decimals() view returns (uint8)"];
    const c = new ethers.Contract(address, abi, rpcProvider);
    const [symbol,name,decimals] = await Promise.all([ c.symbol().catch(()=>null), c.name().catch(()=>null), c.decimals().catch(()=>18) ]);
    const info = { address: addrL, symbol: symbol||address.slice(0,6), name: name||symbol||address.slice(0,8), decimals: decimals||18, logoURI: '' };
    tokenMap.set(info.address, info);
    if (!tokenList.find(t => t.address === info.address)) tokenList.push(info);
    return info;
  } catch(e){ console.warn('fetchOnchainTokenInfo failed', e); return null; }
}

async function fetchPriceForToken(address, decimals, side){
  try {
    if (!address) return;
    const price = await getTokenPriceUSD(address, decimals);
    const amtEl = (side === 'from') ? fromAmountEl : toAmountEl;
    const amt = Number(amtEl.value || 0);

    // small elements under the amount/estimate
    const usdEl = (side === 'from') ? fromUsdSmall : toUsdSmall;
    const unitEl = (side === 'from') ? fromUnitSmall : toUnitSmall;

    if (price != null && !Number.isNaN(amt) && amt>0) {
      usdEl.textContent = '≈ ' + formatUSD(Number(price) * amt);
      usdEl.style.display = 'block';
      unitEl.textContent = `${formatUSD(price)} / unit`;
      unitEl.style.display = 'block';
    } else if (price != null) {
      usdEl.textContent = formatUSD(price);
      usdEl.style.display = 'block';
      unitEl.textContent = `${formatUSD(price)} / unit`;
      unitEl.style.display = 'block';
    } else {
      usdEl.textContent = '—';
      unitEl.textContent = '— / unit';
      usdEl.style.display = 'block';
      unitEl.style.display = 'block';
    }

    // update percent label (exact timeframe if present in cache)
    const cached = priceCache.get(low(address));
    const t = tokenMap.get(low(address));
    try {
      const stat = (t && t.symbol) ? cgStatsMap.get(low(t.symbol)) || cgStatsMap.get(low(t.name || '')) : null;
      const changeEl = (side==='from')? fromChangeEl : toChangeEl;
      if (cached && cached.change !== undefined && cached.change !== null) {
        changeEl.style.display = 'block';
        changeEl.textContent = (cached.change >= 0 ? '+' : '') + Number(cached.change).toFixed(2) + '% (' + (cached.timeframe || '24h') + ')';
        changeEl.style.color = cached.change >= 0 ? '#9ef39e' : '#ff9e9e';
      } else if (stat && typeof stat.change24h === 'number') {
        changeEl.style.display = 'block';
        changeEl.textContent = (stat.change24h >= 0 ? '+' : '') + stat.change24h.toFixed(2) + '% (24h)';
        changeEl.style.color = stat.change24h >= 0 ? '#9ef39e' : '#ff9e9e';
      } else if (changeEl) {
        changeEl.style.display = 'none';
      }
    } catch(e){}
  } catch(e){ console.warn('fetchPriceForToken error', e); }
}
async function fetchBothPrices(){
  const fAddr = low(fromTokenInput.dataset.address || '');
  const tAddr = low(toTokenInput.dataset.address || '');
  const fDec = Number(fromTokenInput.dataset.decimals || 18);
  const tDec = Number(toTokenInput.dataset.decimals || 18);
  await Promise.all([
    fAddr ? fetchPriceForToken(fAddr, fDec, 'from') : Promise.resolve(),
    tAddr ? fetchPriceForToken(tAddr, tDec, 'to') : Promise.resolve()
  ]);
}

/* ================= QUOTE AGGREGATION: 0x + 1inch, fastest then best price */
/* fetch 1inch quote */
async function fetch1InchSwapQuote(fromAddr,toAddr,amountWei){
  try{
    const qUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${amountWei}`;
    const r = await fetchWithTimeout(qUrl,{},3500);
    if(!r.ok) throw new Error('1inch quote fail');
    const j = await r.json();
    return {source:'1inch', toTokenAmount: j.toTokenAmount ? j.toTokenAmount : null, raw:j};
  }catch(e){ return null; }
}

/* fetch 0x quote (uses swap/quote) with API key */
async function fetch0xQuote(fromAddr,toAddr,amountWei){
  try{
    const sellToken = fromAddr === MATIC_ADDR ? 'MATIC' : fromAddr;
    const buyToken = toAddr === MATIC_ADDR ? 'MATIC' : toAddr;
    const url = `${ZEROX_BASE}/swap/v1/quote?sellToken=${encodeURIComponent(sellToken)}&buyToken=${encodeURIComponent(buyToken)}&sellAmount=${amountWei}`;
    const r = await fetchWithTimeout(url, { headers: { '0x-api-key': ZEROX_API_KEY }},3500);
    if(!r.ok) throw new Error('0x quote fail');
    const j = await r.json();
    return {source:'0x', toTokenAmount: j?.buyAmount ?? null, raw:j};
  }catch(e){ return null; }
}

/* normalize big number strings to numbers using decimals */
function normalizeBigNumberString(val, decimals=18){ try{ if(!val) return 0; return Number(ethers.utils.formatUnits(ethers.BigNumber.from(val), decimals)); }catch(e){ return 0; } }

/* get best quote using fastest-first then best-output scoring */
async function getBestQuote(fromAddr,toAddr,amountRaw,fromDecimals,toDecimals,slippagePercent){
  const amountWei = amountRaw;
  // call both in parallel and measure time
  const timers = [];
  function timeCall(fn){ const start = performance.now(); return fn().then(res=>{ const dur = performance.now() - start; return {res,dur}; }).catch(err=>{ const dur = performance.now() - start; return {res:null,dur}; }); }

  const p0 = timeCall(()=>fetch0xQuote(fromAddr,toAddr,amountWei));
  const p1 = timeCall(()=>fetch1InchSwapQuote(fromAddr,toAddr,amountWei));
  const [r0, r1] = await Promise.all([p0, p1]);

  const candidates = [];
  if (r0.res) {
    const norm = normalizeBigNumberString(r0.res.toTokenAmount, toDecimals);
    candidates.push({source:'0x', normalized:norm, raw:r0.res, time:r0.dur});
  }
  if (r1.res) {
    const norm = normalizeBigNumberString(r1.res.toTokenAmount, toDecimals);
    candidates.push({source:'1inch', normalized:norm, raw:r1.res, time:r1.dur});
  }
  if (candidates.length === 0) return null;

  // Score: fastest wins first (weight 0.6) and better output wins (weight 0.4)
  candidates.forEach(c => {
    const speedScore = 1 / (1 + c.time); // faster -> higher
    const outScore = c.normalized;
    c.score = (speedScore * 0.6) + (outScore * 0.4);
  });
  candidates.sort((a,b)=> b.score - a.score);
  return candidates[0]; // best combined
}

/* build and submit swap tx via 1inch swap endpoint (needs fromAddress) */
async function performSwapUsing1inch(fromAddr,toAddr,amountWei,fromDecimals,slippagePercent){
  try{
    const swapUrl = `${ONEINCH_BASE}/swap?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${amountWei}&fromAddress=${userAddress}&slippage=${slippagePercent}`;
    const r = await fetchWithTimeout(swapUrl,{},7000);
    if(!r.ok) throw new Error('1inch swap prepare failed');
    const j = await r.json();
    if(!j || !j.tx) throw new Error('1inch swap returned no tx');
    const tx = j.tx; // {to, data, value, gas, gasPrice}
    const txReq = { to: tx.to, data: tx.data, value: tx.value ? ethers.BigNumber.from(tx.value) : undefined, gasLimit: tx.gas ? ethers.BigNumber.from(tx.gas) : undefined };
    const sent = await signer.sendTransaction(txReq);
    return sent;
  }catch(e){ throw e; }
}

/* perform swap using 0x raw quote (if it includes to/data/value) */
async function performSwapUsing0x(rawQuote){
  try{
    const tx = rawQuote.raw; // 0x quote response
    if(!tx || !tx.to || !tx.data) throw new Error('0x missing tx');
    const txReq = { to: tx.to, data: tx.data, value: tx.value ? ethers.BigNumber.from(tx.value) : undefined, gasLimit: tx.gas ? ethers.BigNumber.from(tx.gas) : undefined };
    const sent = await signer.sendTransaction(txReq);
    return sent;
  }catch(e){ throw e; }
}

/* ================= QUOTE via aggregator debounce */
let quoteTimer = null;
function updateQuoteDebounced(){ clearTimeout(quoteTimer); quoteTimer = setTimeout(()=> updateQuote(), 140); }
async function updateQuote(){
  try {
    const fromAddr = low(fromTokenInput.dataset.address || '');
    const toAddr = low(toTokenInput.dataset.address || '');
    const amount = fromAmountEl.value;
    if (!fromAddr || !toAddr || !amount) { await fetchBothPrices(); return; }
    const fromDecimals = Number(fromTokenInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const toDecimals = Number(toTokenInput.dataset.decimals || tokenMap.get(toAddr)?.decimals || 18);
    const parsed = ethers.utils.parseUnits(String(amount), fromDecimals).toString();

    const best = await getBestQuote(fromAddr,toAddr,parsed,fromDecimals,toDecimals,Number(slippageSel.value||1));
    if(best && best.raw){
      const normalizedOut = best.normalized;
      toAmountEl.value = (normalizedOut===0)? '' : Number(normalizedOut.toFixed(6)).toString();
    } else {
      const r = await fetchWithTimeout(`${ONEINCH_BASE}/quote?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${parsed}`,{},3000);
      if (r.ok){ const j = await r.json(); if (j && j.toTokenAmount) { const formattedTo = ethers.utils.formatUnits(ethers.BigNumber.from(j.toTokenAmount), toDecimals); toAmountEl.value = formattedTo; } }
    }
    await fetchBothPrices();
  } catch (e) {
    console.warn('updateQuote error (aggregator)', e);
    await fetchBothPrices();
  }
}
fromAmountEl.addEventListener('input', ()=>{ updateQuoteDebounced(); updateEstimate(); });

/* ================= SIMPLE MATH ESTIMATE */
async function updateEstimate(){
  try {
    await ensureTokensLoaded();
    resolveTokenInputsIfNeeded();
    const fromAddr = low(fromTokenInput.dataset.address || '');
    const toAddr = low(toTokenInput.dataset.address || '');
    const fromAmount = Number(fromAmountEl.value || 0);
    if (!fromAddr || !toAddr || !fromAmount || Number.isNaN(fromAmount) || fromAmount <= 0) return;
    const fDec = Number(fromTokenInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const tDec = Number(toTokenInput.dataset.decimals || tokenMap.get(toAddr)?.decimals || 18);
    const [fromPrice, toPrice] = await Promise.all([ getTokenPriceUSD(fromAddr, fDec), getTokenPriceUSD(toAddr, tDec) ]);
    if (!fromPrice || !toPrice) return;
    const fromUSD = Number(fromAmount) * Number(fromPrice);
    const estimatedTo = fromUSD / Number(toPrice);
    const display = (Number.isFinite(estimatedTo)) ? Number(estimatedTo.toFixed(6)).toString() : '';
    toAmountEl.value = display;

    // update small price displays under amount/estimate
    fromUsdSmall.style.display = 'block';
    toUsdSmall.style.display = 'block';
    fromUnitSmall.style.display = 'block';
    toUnitSmall.style.display = 'block';

    fromUsdSmall.textContent = `≈ ${formatUSD(fromUSD)}`;
    fromUnitSmall.textContent = `${formatUSD(fromPrice)} / unit`;
    toUsdSmall.textContent = `${formatUSD(toPrice)} / unit`;
    toUnitSmall.textContent = `—`;
  } catch(e){ console.warn('updateEstimate error', e); }
}

/* ================= RESOLVE TYPED TOKENS HEURISTICALLY */
function resolveTokenInputsIfNeeded(){
  const tryResolve = (inputEl) => {
    const val = (inputEl.value || '').trim(); if (!val || inputEl.dataset.address) return;
    const q = val.toLowerCase();
    let found = tokenList.find(t => t.symbol && t.symbol.toLowerCase() === q && (cgStatsMap.has(low(t.symbol)) || cgStatsMap.has(low(t.name))));
    if (!found) found = tokenList.find(t => t.symbol && t.symbol.toLowerCase() === q);
    if (!found) found = tokenList.find(t => t.symbol && t.symbol.toLowerCase().startsWith(q));
    if (!found) found = tokenList.find(t => t.name && t.name.toLowerCase().includes(q));
    if (found){
      inputEl.dataset.address = found.address;
      inputEl.dataset.decimals = found.decimals || 18;
      const logo = (inputEl.id === 'fromToken')? fromLogo : toLogo;
      const chip = (inputEl.id === 'fromToken')? fromChip : toChip;
      const cgImg = (cgStatsMap.get(low(found.symbol)) || {}).image;
      if (cgImg) { logo.src = cgImg; logo.style.display = 'block'; } else if (found.logoURI){ logo.src = found.logoURI; logo.style.display = 'block'; } else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'block'; }
      const box = (inputEl.id === 'fromToken')? fromBox : toBox;
      box.classList.add('has-token');
      ACTIVE_PRICE_ADDRS.add(found.address);
      chip.textContent = found.symbol || found.name || '';
      chip.style.display = 'inline-flex';

      // update 24h/12h change if present
      try {
        const stat = cgStatsMap.get(low(found.symbol)) || cgStatsMap.get(low(found.name));
        const el = (inputEl.id === 'fromToken') ? fromChangeEl : toChangeEl;
        if (stat && typeof stat.change24h === 'number') {
          el.style.display = 'block';
          el.textContent = (stat.change24h >= 0 ? '+' : '') + stat.change24h.toFixed(2) + '% (24h)';
          el.style.color = stat.change24h >= 0 ? '#9ef39e' : '#ff9e9e';
        } else el.style.display = 'none';
      } catch(_) {}
    }
  };
  tryResolve(fromTokenInput); tryResolve(toTokenInput);
}

/* ================= SWAP ICON BEHAVIOR (now in controls) */
swapOutside.addEventListener('click', ()=>{
  swapOutside.classList.add('pressed');
  setTimeout(()=> swapOutside.classList.remove('pressed'), 300);
  // swap values
  const fVal = fromTokenInput.value, tVal = toTokenInput.value;
  const fAddr = fromTokenInput.dataset.address, tAddr = toTokenInput.dataset.address;
  const fDec = fromTokenInput.dataset.decimals, tDec = toTokenInput.dataset.decimals;
  const fLogo = fromLogo.src, tLogoSrc = toLogo.src;
  const aFrom = fromAmountEl.value, aTo = toAmountEl.value;
  fromTokenInput.value = tVal; toTokenInput.value = fVal;
  if (tAddr) fromTokenInput.dataset.address = tAddr; else delete fromTokenInput.dataset.address;
  if (fAddr) toTokenInput.dataset.address = fAddr; else delete toTokenInput.dataset.address;
  if (tDec) fromTokenInput.dataset.decimals = tDec; else delete fromTokenInput.dataset.decimals;
  if (fDec) toTokenInput.dataset.decimals = fDec; else delete toTokenInput.dataset.decimals;
  fromLogo.src = tLogoSrc || ''; fromLogo.style.display = tLogoSrc ? 'block' : 'none';
  toLogo.src = fLogo || ''; toLogo.style.display = fLogo ? 'block' : 'none';
  fromAmountEl.value = aTo; toAmountEl.value = aFrom;
  if (fromTokenInput.dataset.address) fromBox.classList.add('has-token'); else fromBox.classList.remove('has-token');
  if (toTokenInput.dataset.address) toBox.classList.add('has-token'); else toBox.classList.remove('has-token');
  try{ typeof updateQuoteDebounced === 'function' && updateQuoteDebounced(); }catch(e){}
  try{ typeof fetchBothPrices === 'function' && fetchBothPrices(); }catch(e){}
  try{ typeof updateEstimate === 'function' && updateEstimate(); }catch(e){}
});

/* SWAP BUTTON behaviour: connect if needed then aggregate quotes and perform swap */
swapBtn.addEventListener('click', async ()=> {
  try{
    if(!userAddress){ showToast('Connecting wallet...'); const ok = await connectWallet(); if(!ok){ showToast('Wallet connection failed'); return; } }
    // ensure inputs
    const fromAddr = low(fromTokenInput.dataset.address || '');
    const toAddr = low(toTokenInput.dataset.address || '');
    const amount = fromAmountEl.value;
    if(!fromAddr || !toAddr || !amount || Number(amount) <= 0){ showToast('Enter valid amount and tokens'); return; }

    const fromDecimals = Number(fromTokenInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const toDecimals = Number(toTokenInput.dataset.decimals || tokenMap.get(toAddr)?.decimals || 18);
    const amountWei = ethers.utils.parseUnits(String(amount), fromDecimals).toString();
    const slippage = Number(slippageSel.value || 1);

    showToast('Fetching best quote...');
    const best = await getBestQuote(fromAddr,toAddr,amountWei,fromDecimals,toDecimals,slippage);
    if(!best || !best.raw){ showToast('No routes found'); return; }

    // prepare human-friendly amounts
    const approxOut = best.normalized;
    const feePercent = PLATFORM_FEE_PERCENT;
    // fee will be charged on output token (so user sees output minus fee)
    const feeAmount = approxOut * feePercent;
    const finalOutAfterFee = approxOut - feeAmount;

    // Confirm with user
    const label = `Swap ${amount} ${fromTokenInput.value} → ~${approxOut.toFixed(6)} ${toTokenInput.value} (after fee ~${finalOutAfterFee.toFixed(6)}). Fee: ${(feePercent*100).toFixed(5)}%`;
    if(!confirm(label + '\n\nProceed with transaction?')){ showToast('Swap cancelled'); return; }

    showToast('Submitting transaction...');
    let txResp = null;

    // Try preferred source by best.r.source (0x or 1inch)
    if(best.source === '0x'){
      try{ txResp = await performSwapUsing0x(best); }
      catch(e){ console.error('0x swap failed',e); }
    }
    // fallback to 1inch
    if(!txResp){
      try{ txResp = await performSwapUsing1inch(fromAddr,toAddr,amountWei,fromDecimals,slippage); }
      catch(e){ console.error('1inch swap failed',e); }
    }
    if(!txResp){ showToast('Swap failed (no tx)'); return; }
    showToast('Transaction sent — waiting for confirmation');
    const receipt = await txResp.wait();
    if(!receipt || receipt.status !== 1){ showToast('Swap transaction failed. Check explorer.'); return; }

    // At this point we have the main swap done. Next: request small fee transfer from user.
    try {
      // compute fee in output token units (approx) and then send a small transfer
      const feeDecimalAmount = feeAmount; // approximate (we used normalized number)
      if (feeDecimalAmount > 0 && FEE_RECIPIENT && FEE_RECIPIENT !== '0xYOUR_FEE_ADDRESS_HERE'){
        // If output token is MATIC native, send native value
        if (toAddr === MATIC_ADDR){
          // convert decimal to wei (toDecimals == 18)
          const feeWei = ethers.utils.parseUnits(String(feeDecimalAmount), 18);
          const tx = { to: FEE_RECIPIENT, value: feeWei };
          showToast('Sending small fee transfer (requires your signature)...');
          const sentFeeTx = await signer.sendTransaction(tx);
          await sentFeeTx.wait();
          showToast('Fee transfer sent');
        } else {
          // ERC20 transfer from user's wallet for the output token - amount in token decimals
          const outTokenAddr = toAddr;
          const tokenDecimals = toDecimals || 18;
          const feeAmountUnits = ethers.utils.parseUnits(String(feeDecimalAmount), tokenDecimals);
          const erc20Abi = ["function transfer(address to, uint256 val) returns (bool)"];
          const tokenContract = new ethers.Contract(outTokenAddr, erc20Abi, signer);
          showToast('Sending tiny fee transfer (requires your signature)...');
          const txFee = await tokenContract.transfer(FEE_RECIPIENT, feeAmountUnits);
          await txFee.wait();
          showToast('Fee transfer sent');
        }
      } else {
        if (!FEE_RECIPIENT || FEE_RECIPIENT === '0xYOUR_FEE_ADDRESS_HERE'){
          showToast('Fee recipient not set — fee skipped (placeholder present)');
        }
      }
    } catch(feErr){ console.warn('fee transfer failed', feErr); showToast('Fee transfer failed or cancelled by user'); }

    showToast('Swap completed. Check your wallet for details.');
  }catch(e){ console.error('swap error', e); showToast('Swap error: '+(e.message||e)); }
});

/* Connect wallet (WalletConnect prioritized, MetaMask fallback) */
let provider = null, signer = null, userAddress = null, web3modal = null;
async function initWeb3Modal(){
  try{
    web3modal = new window.WalletConnectWeb3Modal.default({
      projectId: WALLETCONNECT_PROJECT_ID,
      themeMode: 'dark',
      // prefer WalletConnect
      walletConnectVersion: 2,
      modalOptions: { tryWalletConnectOnLoad: false }
    });
  }catch(e){ console.warn('web3modal init', e); web3modal = null; }
}
initWeb3Modal();

function setConnectedUI(address){
  if(address){ addrChip.style.display = 'inline-block'; addrChip.textContent = `${address.slice(0,6)}…${address.slice(-4)}`; }
  else { addrChip.style.display = 'none'; }
  const pills = document.querySelectorAll('.electric-pill');
  pills.forEach(p => { if(address) p.classList.add('connected'); else p.classList.remove('connected'); });
}

async function connectWallet(){
  try{
    // prefer WalletConnect flow on mobile and desktop (better deep-link handling)
    if (web3modal && WALLETCONNECT_PROJECT_ID && WALLETCONNECT_PROJECT_ID !== 'WALLETCONNECT_PROJECT_ID'){
      try {
        const wc = await web3modal.openModal();
        if(wc){
          provider = new ethers.providers.Web3Provider(wc);
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          setConnectedUI(userAddress);
          return true;
        }
      } catch(e){
        console.warn('web3modal openModal failed', e);
      }
    }

    // Fallback: MetaMask if installed
    if (window.ethereum){
      try {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send('eth_requestAccounts', []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        setConnectedUI(userAddress);
        return true;
      } catch(e){}
    }

    // mobile deep-link attempt: open wallet apps
    if (/Mobi|Android|iPhone/i.test(navigator.userAgent)){
      // Try deep linking to popular wallets (the browser may block some attempts)
      const links = [
        'wc://', // generic
        'metamask://',
        'trust://',
        'rainbow://',
        'ethereum:'
      ];
      for(const l of links){
        try{ window.location.href = l; }catch(e){}
      }
    }

    showToast('No wallet found. Install MetaMask or open a wallet app (WalletConnect preferred).');
    return false;
  } catch(e){
    console.error('connect error', e);
    showToast('Wallet connection failed: ' + (e.message || e));
    return false;
  }
}
connectFloating.addEventListener('click', connectWallet);

/* ================= BACKGROUND REFRESH: every 10s */
async function refreshCoinGeckoMarkets(){
  try {
    const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`;
    const rm = await fetchWithTimeout(marketsUrl, {}, 5000);
    if (!rm.ok) throw new Error('CG markets refresh failed');
    const jm = await rm.json();
    jm.forEach(c => {
      const sym = low(c.symbol||''), name = low(c.name||'');
      const stat = { price: (typeof c.current_price === 'number' ? c.current_price : null), change24h: (typeof c.price_change_percentage_24h === 'number' ? c.price_change_percentage_24h : null), volume24h: (typeof c.total_volume === 'number' ? c.total_volume : 0), image: c.image||'', volume12h: null, timeframe:'24h' };
      if (sym) cgStatsMap.set(sym, stat);
      if (name) cgStatsMap.set(name, stat);
      tokenList.forEach(t => { if (t.symbol && low(t.symbol) === sym) priceCache.set(t.address, { price: stat.price, ts: nowTs(), change: stat.change24h, timeframe:'24h' }); });
    });
    fetchBothPrices();
    updateEstimate();
    updateUsdVisibility();
  } catch(e){ console.warn('refreshCoinGeckoMarkets error', e); }
}
let refreshInterval = null;
function startBackgroundRefresh(){
  if (refreshInterval) clearInterval(refreshInterval);
  refreshCoinGeckoMarkets();
  refreshInterval = setInterval(refreshCoinGeckoMarkets, 10000); // refresh every 10s
}

/* Active price refresh for chosen tokens every 10s */
let activePriceInterval = null;
function scheduleActivePriceRefresh(){
  updateUsdVisibility();
  if (activePriceInterval) return;
  (async()=>{
    await refreshActivePrices();
    activePriceInterval = setInterval(refreshActivePrices, 10000);
  })();
}
async function refreshActivePrices(){
  const addrs = Array.from(ACTIVE_PRICE_ADDRS).filter(a => a && a.length === 42);
  if (!addrs.length) return;
  await Promise.all(addrs.map(async addr => {
    const decimals = tokenMap.get(addr)?.decimals || 18;
    const price = await getTokenPriceUSD(addr, decimals);
    if (addr === low(fromTokenInput.dataset.address || '')) fetchPriceForToken(addr, decimals, 'from');
    if (addr === low(toTokenInput.dataset.address || '')) fetchPriceForToken(addr, decimals, 'to');
  }));
}

/* ================= UTILITY: updateUsdVisibility */
function updateUsdVisibility(){
  if (!fromTokenInput.dataset.address) { fromUsdSmall.style.display = 'none'; fromUnitSmall.style.display='none'; ACTIVE_PRICE_ADDRS.delete(low(fromTokenInput.dataset.address||'')); } else { fromUsdSmall.style.display = 'block'; fromUnitSmall.style.display='block'; ACTIVE_PRICE_ADDRS.add(low(fromTokenInput.dataset.address||'')); }
  if (!toTokenInput.dataset.address) { toUsdSmall.style.display = 'none'; toUnitSmall.style.display='none'; ACTIVE_PRICE_ADDRS.delete(low(toTokenInput.dataset.address||'')); } else { toUsdSmall.style.display = 'block'; toUnitSmall.style.display='block'; ACTIVE_PRICE_ADDRS.add(low(toTokenInput.dataset.address||'')); }
}

/* ================= SUGGESTIONS HIDE OUTSIDE CLICK & ESC */
document.addEventListener('click', (ev)=>{
  const inInputOrSuggest = ev.target.closest('.input-box') || ev.target.closest('.suggestions') || ev.target.closest('#fromToken') || ev.target.closest('#toToken');
  if (!inInputOrSuggest){
    fromSuggestions.style.display = 'none';
    toSuggestions.style.display = 'none';
  }
});
document.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape'){ fromSuggestions.style.display='none'; toSuggestions.style.display='none'; } });

/* ================= CARET HELPERS: focus + place caret at end for faster typing */
function placeCaretAtEnd(inputEl){
  try{
    const len = (inputEl.value || '').length;
    inputEl.setSelectionRange(len, len);
  }catch(e){}
}
function focusAndPlaceCaretAtEnd(inputEl){
  try{
    inputEl.focus();
    placeCaretAtEnd(inputEl);
  }catch(e){}
}

/* Make whole left area clickable to focus the input and position caret at end for faster editing */
fromBox.querySelector('.left').addEventListener('click', (e)=>{
  if (e.target.closest('.suggestions') || e.target.closest('input[type="number"]')) return;
  focusAndPlaceCaretAtEnd(fromTokenInput);
  showDefaultList('from');
});
toBox.querySelector('.left').addEventListener('click', (e)=>{
  if (e.target.closest('.suggestions') || e.target.closest('input[type="number"]')) return;
  focusAndPlaceCaretAtEnd(toTokenInput);
  showDefaultList('to');
});

/* ================= INIT */
(async function init(){
  await ensureTokensLoaded();
  // preselect USDC as from if available
  const usdc = tokenList.find(t => t.address && t.address.toLowerCase() === USDC_ADDR.toLowerCase());
  if (usdc) {
    fromTokenInput.value = usdc.symbol || 'USDC';
    fromTokenInput.dataset.address = usdc.address;
    fromTokenInput.dataset.decimals = usdc.decimals || 6;
    const cgImg = (cgStatsMap.get(low(usdc.symbol)) || {}).image;
    if (cgImg) { fromLogo.src = cgImg; fromLogo.style.display='block'; } else if (usdc.logoURI) { fromLogo.src = usdc.logoURI; fromLogo.style.display='block'; }
    ACTIVE_PRICE_ADDRS.add(low(usdc.address));
    fromChip.textContent = usdc.symbol || 'USDC'; fromChip.style.display = 'inline-flex';
    fromBox.classList.add('has-token');
  }
  const top = tokenList.find(t => cgStatsMap.has(low(t.symbol)));
  if (top) {
    toTokenInput.value = top.symbol || top.name;
    toTokenInput.dataset.address = top.address;
    toTokenInput.dataset.decimals = top.decimals || 18;
    const cgImg = (cgStatsMap.get(low(top.symbol)) || {}).image;
    if (cgImg) { toLogo.src = cgImg; toLogo.style.display='block'; } else if (top.logoURI) { toLogo.src = top.logoURI; toLogo.style.display='block'; }
    ACTIVE_PRICE_ADDRS.add(low(top.address));
    toChip.textContent = top.symbol || top.name; toChip.style.display = 'inline-flex';
    toBox.classList.add('has-token');
  }
  updateUsdVisibility();
  fetchBothPrices();
  startBackgroundRefresh();
  scheduleActivePriceRefresh();

  // animate swapOutside entrance
  setTimeout(()=> { swapOutside.classList.add('enter'); }, 200);
})();

/* SLIPPAGE UI */
slippageSel.addEventListener('change', ()=>{ /* slippage integrated in swap flow */ });

/* expose some functions globally for debugging or external calls */
window.getTokenPriceUSD = getTokenPriceUSD;
window.applyTokenSelection = applyTokenSelection;
window.clearTokenSelection = clearTokenSelection;
window.updateQuoteDebounced = updateQuoteDebounced;
window.fetchBothPrices = fetchBothPrices;
window.updateEstimate = updateEstimate;
window.scheduleActivePriceRefresh = scheduleActivePriceRefresh;
</script>

</body>
</html>
