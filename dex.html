<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>NOLA Exchange — Full</title>
<style>
/* ===== RESET & THEME ===== */
*{margin:0;padding:0;box-sizing:border-box;font-family:'Arial',sans-serif}
html,body{height:100%;} /* lock viewport */
body{overflow:hidden;background:radial-gradient(circle at center,#0c0014,#1a002b 80%);color:#fff;min-height:100vh;display:flex;align-items:center;justify-content:center}
:root{
  --accent-1:#b445ff;--accent-2:#7013ff;
  --glass:rgba(255,255,255,0.05);--glass-2:rgba(255,255,255,0.03);
  --suggest-bg:rgba(25,0,50,0.98);
  --shadow:0 0 25px rgba(180,0,255,0.3);
  --container-max:520px;
}

/* NEBULA + PARTICLES */
body::before{content:'';position:fixed;left:-50%;top:-50%;width:200%;height:200%;background:radial-gradient(circle,rgba(150,0,255,0.12),transparent 60%);animation:nebulaMove 20s infinite alternate ease-in-out;z-index:-2}
@keyframes nebulaMove{0%{transform:translate(-10%,-10%)}100%{transform:translate(5%,5%)}}
.particle{position:absolute;width:2px;height:2px;background:#b445ff;border-radius:50%;opacity:0.8;animation:floatParticle linear infinite;z-index:-1}
@keyframes floatParticle{0%{transform:translateY(0) translateX(0);opacity:0.8}50%{transform:translateY(-50px) translateX(20px);opacity:0.4}100%{transform:translateY(0) translateX(0);opacity:0.8}}

/* TOP LOGO moved down to sit above section */
.logo{
  width:96px;height:auto;display:block;margin:0 auto;pointer-events:none;
  animation:logoGlow 5s ease-in-out infinite alternate,logoRotate 30s linear infinite;
  z-index:998;position:fixed;left:50%;top:10vh;transform:translateX(-50%);
}
@keyframes logoGlow{0%{filter:drop-shadow(0 0 12px #9c00ff)}50%{filter:drop-shadow(0 0 30px #d15fff)}100%{filter:drop-shadow(0 0 12px #9c00ff)}}
@keyframes logoRotate{0%{transform:translateX(-50%) rotateY(0deg)}100%{transform:translateX(-50%) rotateY(360deg)}}

/* CONTAINER (centered card) - fixed size to avoid page scroll */
.container{width:92%;max-width:var(--container-max);background:var(--glass);border:1px solid rgba(255,255,255,0.08);border-radius:20px;padding:18px 18px 72px 18px;backdrop-filter:blur(18px);box-shadow:var(--shadow);position:relative;overflow:visible}
h2{text-align:center;font-size:22px;font-weight:600;margin-bottom:12px;color:#e0b3ff;text-shadow:0 0 8px #b445ff}

/* UNIFIED ROW */
.input-box{margin-top:12px;padding:10px;background:rgba(255,255,255,0.04);border-radius:12px;border:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;gap:10px;position:relative}
.input-box .left{display:flex;align-items:center;gap:10px;min-width:0;flex:1}
.token-icon{width:36px;height:36px;border-radius:50%;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;position:relative;border:1px solid rgba(255,255,255,0.04)}
.token-icon img{width:100%;height:100%;object-fit:cover;display:block;border-radius:50%}
.token-chip{position:absolute;right:-6px;bottom:-6px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));padding:4px 8px;border-radius:999px;font-weight:800;font-size:11px;color:#fff;box-shadow:0 8px 22px rgba(180,68,255,0.12),inset 0 -3px 8px rgba(0,0,0,0.12);display:none;white-space:nowrap;transform:translate(6px,6px)}
.input-box.has-token .token-chip{display:inline-flex}

/* INPUT FIELD (one text input per row) */
.input-field{display:flex;flex-direction:column;min-width:0;width:100%}
.input-field input[type="text"]{padding:8px 10px;border-radius:10px;border:none;background:transparent;color:#fff;width:100%;outline:none;font-size:15px}
.input-amount{margin-left:8px;min-width:120px}
.input-amount input{width:100%;padding:10px 12px;border-radius:10px;border:none;background:rgba(255,255,255,0.03);color:#fff;font-size:15px;outline:none}

/* USD RIGHT */
.usd-right{position:absolute;right:12px;top:50%;transform:translateY(-50%);font-size:13px;color:rgba(255,255,255,0.9);font-weight:700;text-align:right}

/* SUGGESTIONS: fixed height scroll inside; card no scroll */
.suggestions{position:absolute;top:58px;left:12px;right:12px;background:var(--suggest-bg);border-radius:12px;padding:6px;max-height:220px;overflow:auto;display:none;z-index:220;box-shadow:0 10px 30px rgba(120,0,255,0.08)}
.suggestion-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:10px;cursor:pointer;justify-content:space-between}
.suggestion-item:hover{background:linear-gradient(90deg, rgba(180,68,255,0.06), rgba(112,19,255,0.04))}
.suggestion-left{display:flex;align-items:center;gap:10px;min-width:0}
.suggestion-left img{width:28px;height:28px;border-radius:50%;object-fit:cover}
.suggestion-main{display:flex;flex-direction:column;min-width:0}
.suggestion-symbol{font-weight:700;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.suggestion-name{font-size:12px;opacity:0.8;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.suggestion-price-pill{min-width:70px;text-align:right;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03);font-weight:700;font-size:12px}

/* BOTTOM CONTROLS (inside card, absolute) */
.bottom-controls{position:absolute;left:12px;right:12px;bottom:12px;display:flex;align-items:center;justify-content:space-between;gap:12px;pointer-events:auto}

/* SLIPPAGE: custom professional control left */
.slippage-wrap{display:inline-block;position:relative}
.slippage{appearance:none;-webkit-appearance:none;padding:10px 44px 10px 12px;border-radius:12px;border:none;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#fff;font-weight:800;box-shadow:0 10px 30px rgba(106,0,255,0.12);cursor:pointer;font-size:14px;outline:none;min-width:120px}
.slippage:focus{box-shadow:0 14px 40px rgba(180,68,255,0.18)}
.slippage-wrap::after{
  content:'';position:absolute;right:12px;top:50%;transform:translateY(-50%);width:18px;height:18px;background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20'><path fill='white' d='M6 8l4 4 4-4' /></svg>");background-repeat:no-repeat;background-position:center;opacity:0.95;pointer-events:none
}
#customSlippage{padding:8px 10px;border-radius:10px;border:none;background:rgba(255,255,255,0.03);color:#fff;display:none;width:84px;outline:none}

/* SWITCH (swap) control inside card bottom-right */
.swap-inside{width:52px;height:52px;border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);box-shadow:0 10px 30px rgba(120,0,255,0.08),0 2px 8px rgba(0,0,0,0.35);cursor:pointer;font-size:20px;color:#fff;transition:transform 160ms ease,box-shadow 160ms ease;backdrop-filter:blur(6px)}
.swap-inside:hover{transform:translateY(-6px) rotate(-8deg)}

/* ELECTRIC PILL SWAP BUTTON (outside the card below) */
.electric-outside-wrap{display:flex;align-items:center;justify-content:center;margin-top:18px}
.electric-btn{display:inline-block;border:0;background:transparent;padding:0;cursor:pointer}
.electric-pill{
  position:relative;display:inline-flex;align-items:center;gap:12px;padding:12px 32px;border-radius:999px;background:linear-gradient(90deg,var(--accent-1),var(--accent-2));box-shadow:0 18px 46px rgba(180,68,255,0.18);color:#fff;font-weight:800;font-size:16px;border:none;outline:none;overflow:hidden;
  transition:transform 140ms ease,box-shadow 140ms ease;
}
.electric-pill:active{transform:translateY(-1px) scale(.998)}
.electric-pill .sweep{position:absolute;left:-30%;top:-10%;width:42%;height:120%;background:linear-gradient(90deg,rgba(255,255,255,0.5),rgba(255,255,255,0.12),rgba(255,255,255,0.02));transform:skewX(-18deg);opacity:0.18;filter:blur(10px);border-radius:12px;animation:slideSweep 2.1s linear infinite}
@keyframes slideSweep{0%{transform:translateX(-160%) skewX(-18deg)}50%{transform:translateX(120%) skewX(-18deg)}100%{transform:translateX(360%) skewX(-18deg)}}
.electric-pill .label{position:relative;z-index:2;pointer-events:none}
.electric-pill .icon{
  width:28px;height:28px;border-radius:999px;background:rgba(255,255,255,0.08);display:inline-flex;align-items:center;justify-content:center;font-weight:900;z-index:2;
  box-shadow:inset 0 -4px 8px rgba(0,0,0,0.18);
}

/* TOP-RIGHT CONNECT */
.top-right-connect{position:fixed;right:18px;top:18px;z-index:70;display:flex;gap:10px;align-items:center}
.addr-chip{padding:8px 12px;border-radius:12px;background:rgba(255,255,255,0.03);font-weight:700;display:none}
.connect-floating{background:linear-gradient(90deg,var(--accent-1),var(--accent-2));color:#fff;padding:10px 14px;border-radius:12px;border:none;cursor:pointer;font-weight:800;box-shadow:0 10px 30px rgba(106,0,255,0.12)}

/* FOOTER (small fixed) */
.footer{position:fixed;left:0;right:0;bottom:8px;display:flex;align-items:center;justify-content:center;z-index:40;color:rgba(255,255,255,0.6);font-size:12px;pointer-events:none}

/* RESPONSIVE */
@media(max-width:520px){
  :root{--container-max:92%;}
  .container{padding:14px 14px 96px 14px;border-radius:16px}
  .logo{top:8vh;width:76px}
  .input-amount{min-width:86px}
  .slippage{min-width:98px;padding:8px 36px 8px 10px}
  .swap-inside{width:48px;height:48px}
  .electric-pill{padding:10px 20px;font-size:14px}
}
</style>
</head>
<body>

<!-- particles created by script -->
<img id="logoFloat" class="logo" src="data:image/svg+xml;utf8,<?xml version='1.0' encoding='utf-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'><defs><linearGradient id='g' x1='0' x2='1'><stop offset='0' stop-color='%23b445ff'/><stop offset='1' stop-color='%237013ff'/></linearGradient></defs><rect rx='28' ry='28' width='200' height='200' fill='url(%23g)'/><text x='50%' y='54%' font-size='56' fill='white' font-family='Arial' font-weight='700' text-anchor='middle' dominant-baseline='middle'>N</text></svg>" alt="NOLA Logo">

<!-- top-right connect -->
<div class="top-right-connect">
  <div id="addrChip" class="addr-chip"></div>
  <button id="connectFloating" class="connect-floating">Connect Wallet</button>
</div>

<!-- main card -->
<div class="container" role="main" aria-label="NOLA Exchange">
  <h2>NOLA Exchange</h2>

  <!-- FROM -->
  <div class="input-box" id="fromBox" style="position:relative;">
    <div class="left">
      <div class="token-icon" id="fromIcon">
        <img id="fromLogo" src="" alt="" style="display:none">
        <span class="token-chip" id="fromChip" style="display:none">---</span>
      </div>
      <div class="input-field">
        <input id="fromToken" placeholder="Token symbol or contract (paste address too)" style="padding:8px 10px;border-radius:10px;border:none;background:transparent;color:#fff;width:100%">
      </div>
      <div class="input-amount" style="min-width:120px;">
        <input id="fromAmount" placeholder="Amount" type="number" step="any">
      </div>
    </div>
    <div class="usd-right" id="fromUsd" style="display:none">≈ $—</div>
    <div class="suggestions" id="fromSuggestions" data-side="from"></div>
  </div>

  <!-- TO -->
  <div class="input-box" id="toBox" style="position:relative;margin-top:12px;">
    <div class="left">
      <div class="token-icon" id="toIcon">
        <img id="toLogo" src="" alt="" style="display:none">
        <span class="token-chip" id="toChip" style="display:none">---</span>
      </div>
      <div class="input-field">
        <input id="toToken" placeholder="Token symbol or contract (paste address too)" style="padding:8px 10px;border-radius:10px;border:none;background:transparent;color:#fff;width:100%">
      </div>
      <div class="input-amount" style="min-width:120px;">
        <input id="toAmount" placeholder="Estimate" readonly>
      </div>
    </div>
    <div class="usd-right" id="toUsd" style="display:none">≈ $—</div>
    <div class="suggestions" id="toSuggestions" data-side="to"></div>
  </div>

  <!-- bottom controls inside card -->
  <div class="bottom-controls" aria-hidden="false">
    <div class="slippage-wrap">
      <select id="slippage" class="slippage" title="Select slippage">
        <option value="0.1">0.1%</option><option value="0.5">0.5%</option><option value="1" selected>1%</option><option value="2">2%</option><option value="custom">Custom</option>
      </select>
      <input id="customSlippage" placeholder="Custom %" />
    </div>

    <!-- swap (switch) moved inside the card, right bottom -->
    <div id="swapOutside" class="swap-inside" title="Swap From ↔ To">⇅</div>
  </div>
</div>

<!-- electric swap button placed outside card (below) -->
<div class="electric-outside-wrap" aria-hidden="false">
  <button id="swapBtn" class="electric-btn" title="Swap">
    <span class="electric-pill" role="button" aria-pressed="false">
      <span class="sweep" aria-hidden="true"></span>
      <span class="icon">⇄</span>
      <span class="label">Swap</span>
    </span>
  </button>
</div>

<!-- footer (small) -->
<div class="footer">© 2025 NOLA — All rights reserved</div>

<!-- LIBS -->
<script src="https://cdn.jsdelivr.net/npm/ethers/dist/ethers.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
<script src="https://unpkg.com/@web3modal/html@2.1.1/dist/index.js"></script>
<script src="https://unpkg.com/@walletconnect/web3modal@2.6.4/dist/w3m.min.js"></script>

<script>
/* ================= PARTICLES */
(function createParticles(){ for(let i=0;i<60;i++){ const p=document.createElement('div'); p.className='particle'; p.style.top=(Math.random()*100)+'%'; p.style.left=(Math.random()*100)+'%'; p.style.width=(Math.random()*3+1)+'px'; p.style.height=(Math.random()*3+1)+'px'; p.style.animationDuration=(Math.random()*10+5)+'s'; document.body.appendChild(p); }})();

/* ================= CONFIG & STATE (unchanged) */
const CHAIN_ID = 137;
const ONEINCH_BASE = `https://api.1inch.io/v5.0/${CHAIN_ID}`;
const COINGECKO_CHAIN = 'polygon-pos';
const FALLBACK_RPC = "https://polygon-rpc.com";
const USDC_ADDR = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';
const WETH_ADDR = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619';
const MATIC_ADDR = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const WALLETCONNECT_PROJECT_ID = "6557a92e3698182727669d41cbeb95a1";

let tokenList = [];
let tokenMap = new Map();
let cgStatsMap = new Map();
const priceCache = new Map();
const suggestionCache = new Map();
const ACTIVE_PRICE_ADDRS = new Set();
const PRICE_TTL = 7000; // 7s TTL
const SUGGEST_LIMIT = 12;
const DARK_SVG_PLACEHOLDER = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36"><rect width="100%" height="100%" rx="8" ry="8" fill="#151225"/></svg>`);

/* ================= DOM REFS (updated to match moved elements) */
const $ = id => document.getElementById(id);
const fromTokenInput = $('fromToken'), toTokenInput = $('toToken');
const fromAmountEl = $('fromAmount'), toAmountEl = $('toAmount');
const fromUsd = $('fromUsd'), toUsd = $('toUsd');
const fromLogo = $('fromLogo'), toLogo = $('toLogo');
const fromChip = $('fromChip'), toChip = $('toChip');
const fromSuggestions = $('fromSuggestions'), toSuggestions = $('toSuggestions');
const swapOutside = $('swapOutside'), swapBtn = $('swapBtn'); // ids preserved
const fromBox = $('fromBox'), toBox = $('toBox');
const connectFloating = $('connectFloating'), addrChip = $('addrChip');
const slippageSel = $('slippage'), customSlippage = $('customSlippage');

/* ================= HELPERS (unchanged behaviour) */
const isAddress = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
const low = s => (s||'').toLowerCase();
const nowTs = ()=> Date.now();
function formatUSD(v){ if (v===null||v===undefined||!Number.isFinite(v)) return '—'; const n=Number(v); const opts={style:'currency',currency:'USD',maximumFractionDigits:2,minimumFractionDigits:2}; if(Math.abs(n)>0&&Math.abs(n)<0.01){opts.maximumFractionDigits=6;opts.minimumFractionDigits=4;} return new Intl.NumberFormat('en-US',opts).format(n); }
function fetchWithTimeout(url,opts={},ms=3000){ const controller=new AbortController(); const id=setTimeout(()=>controller.abort(),ms); const init=Object.assign({},opts,{signal:controller.signal}); return fetch(url,init).finally(()=>clearTimeout(id)); }
async function fetchJson(url,opts){ const r = await fetch(url,opts); if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); }

/* ================= LOAD TOKENS & COINGECKO MARKETS (unchanged) */
async function loadTokensAndMarkets(){
  try {
    const r = await fetch('https://tokens.coingecko.com/polygon-pos/all.json');
    const j = await r.json();
    tokenList = (j.tokens||[]).map(t => ({ address: low(t.address), symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||t.logo||'' }));
    tokenList.forEach(t => tokenMap.set(t.address, t));
    if (!tokenMap.has(MATIC_ADDR)) tokenMap.set(MATIC_ADDR, { address: MATIC_ADDR, symbol:'MATIC', name:'Polygon', decimals:18, logoURI: '' });

    try {
      const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`;
      const rm = await fetchWithTimeout(marketsUrl, {}, 4000);
      const jm = await rm.json();
      jm.forEach(c => {
        const sym = low(c.symbol||''), name = low(c.name||'');
        const stat = { price: (typeof c.current_price === 'number' ? c.current_price : null), change24h: (typeof c.price_change_percentage_24h === 'number' ? c.price_change_percentage_24h : null), volume24h: (typeof c.total_volume === 'number' ? c.total_volume : 0), image: c.image||'', volume12h: null };
        if (sym) cgStatsMap.set(sym, stat);
        if (name) cgStatsMap.set(name, stat);
      });
    } catch(e){ console.warn('CoinGecko markets failed', e); }

    try {
      const r1 = await fetch(`${ONEINCH_BASE}/tokens`);
      const j1 = await r1.json();
      if (j1 && j1.tokens) {
        Object.values(j1.tokens).forEach(t => {
          const addr = low(t.address||'');
          if (!addr) return;
          if (tokenMap.has(addr)) return;
          const obj = { address: addr, symbol: t.symbol||'', name: t.name||'', decimals: t.decimals||18, logoURI: t.logoURI||'' };
          tokenList.push(obj); tokenMap.set(addr, obj);
        });
      }
    } catch(e){ /* ignore */ }

    // dedupe
    const seen = new Set();
    tokenList = tokenList.filter(t => { if(!t||!t.address) return false; if(seen.has(t.address)) return false; seen.add(t.address); return true; });
    console.log('Loaded tokens:', tokenList.length);
  } catch(e){ console.error('loadTokensAndMarkets error', e); }
}
let tokensLoadedPromise = loadTokensAndMarkets();
async function ensureTokensLoaded(){ if (!tokensLoadedPromise) tokensLoadedPromise = loadTokensAndMarkets(); await tokensLoadedPromise; }

/* ================= PRICE SOURCES, QUOTE, SUGGESTIONS, SELECTION ETC.
   All original functions remain intact and unchanged except for a couple
   small UI-focus helper calls to keep caret at end after selection. */

/* ... (For brevity in this message the functions are kept identical to previous version)
   We'll reinsert the exact same implementations for price fetching, suggestion
   building, autocomplete setup, applyTokenSelection, paste handling, quote
   fetching, estimate calculation, token resolving, wallet connect, background
   refresh and intervals. The logic is the same as before. ... */

/* To keep the reply concise, the unmodified functions (fetch1InchQuotePrice,
   fetchCoingeckoContractPrice, fetchCoingeckoSimple, fetchDexscreenerPrice,
   derivePriceViaWeth, getTokenPriceUSD, makeSuggestionItem,
   showDefaultList, setupAutocomplete, renderSuggestionsFromCache, applyTokenSelection,
   clearTokenSelection, fetchOnchainTokenInfo, fetchPriceForToken, fetchBothPrices,
   updateQuoteDebounced, updateQuote, updateEstimate, resolveTokenInputsIfNeeded,
   swapOutside click handler, swapBtn click handler, wallet connect init and
   refresh loops) remain exactly as in the previous full version you already
   approved. For transparency they are present below exactly unchanged. */

/* ================= Insert unchanged large code block ================== */

/* (START UNCHANGED BLOCK) */
async function fetch1InchQuotePrice(addr, decimals=18){
  try {
    const amountBN = ethers.BigNumber.from(10).pow(decimals);
    const qUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${addr}&toTokenAddress=${USDC_ADDR}&amount=${amountBN.toString()}`;
    const res = await fetchWithTimeout(qUrl,{},3000);
    if (!res.ok) throw new Error('1inch non-ok');
    const j = await res.json();
    if (!j || !j.toTokenAmount) throw new Error('1inch no toTokenAmount');
    const usdcAmountBN = ethers.BigNumber.from(j.toTokenAmount);
    const usdc = Number(ethers.utils.formatUnits(usdcAmountBN, j.toToken?.decimals ?? 6));
    if (!Number.isFinite(usdc) || usdc <= 0) throw new Error('1inch invalid price');
    return usdc;
  } catch(e){ throw e; }
}
async function fetchCoingeckoContractPrice(addr){
  try {
    const url = `https://api.coingecko.com/api/v3/coins/${COINGECKO_CHAIN}/contract/${addr}`;
    const res = await fetchWithTimeout(url,{},3000);
    if (!res.ok) throw new Error('cg contract non-ok');
    const j = await res.json();
    const price = j?.market_data?.current_price?.usd;
    const change = j?.market_data?.price_change_percentage_24h;
    if (typeof price === 'number' && price > 0) return { price, change };
    throw new Error('cg no price');
  } catch(e){ throw e; }
}
async function fetchCoingeckoSimple(addr){
  try {
    const url = `https://api.coingecko.com/api/v3/simple/token_price/${COINGECKO_CHAIN}?contract_addresses=${addr}&vs_currencies=usd`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('cg simple non-ok');
    const j = await res.json();
    const v = j[low(addr)]?.usd ?? null;
    if (v && typeof v === 'number' && v > 0) return v;
    throw new Error('cg simple no price');
  } catch(e){ throw e; }
}
async function fetchDexscreenerPrice(addr){
  try {
    const url = `https://api.dexscreener.com/latest/dex/tokens/${addr}`;
    const res = await fetchWithTimeout(url,{},3000);
    if (!res.ok) throw new Error('dexscreener non-ok');
    const j = await res.json();
    const pairs = j?.pairs || [];
    for (const p of pairs){
      if (p?.priceUsd){ const v = Number(p.priceUsd); if (Number.isFinite(v) && v>0) return v; }
      if (p?.price){ const v = Number(p.price); if (Number.isFinite(v) && v>0) return v; }
    }
    throw new Error('dexscreener no price');
  } catch(e){ throw e; }
}
async function derivePriceViaWeth(addr, decimals=18){
  try {
    const amountBN = ethers.BigNumber.from(10).pow(decimals);
    const qUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${addr}&toTokenAddress=${WETH_ADDR}&amount=${amountBN.toString()}`;
    const res = await fetchWithTimeout(qUrl,{},3000);
    if (!res.ok) throw new Error('1inch->weth non-ok');
    const j = await res.json();
    if (!j || !j.toTokenAmount) throw new Error('1inch->weth no toTokenAmount');
    const wethAmountBN = ethers.BigNumber.from(j.toTokenAmount);
    const weth = Number(ethers.utils.formatUnits(wethAmountBN, j.toToken?.decimals ?? 18));
    if (!Number.isFinite(weth) || weth <= 0) throw new Error('1inch->weth invalid');

    const qUrl2 = `${ONEINCH_BASE}/quote?fromTokenAddress=${WETH_ADDR}&toTokenAddress=${USDC_ADDR}&amount=${ethers.utils.parseUnits(String(weth), 18).toString()}`;
    const res2 = await fetchWithTimeout(qUrl2, {}, 3000);
    if (!res2.ok) throw new Error('weth->usdc non-ok');
    const j2 = await res2.json();
    if (!j2 || !j2.toTokenAmount) throw new Error('weth->usdc no toTokenAmount');
    const usdcAmountBN = ethers.BigNumber.from(j2.toTokenAmount);
    const usdc = Number(ethers.utils.formatUnits(usdcAmountBN, j2.toToken?.decimals ?? 6));
    if (!Number.isFinite(usdc) || usdc <= 0) throw new Error('weth->usdc invalid');
    const price = usdc * weth;
    if (!Number.isFinite(price) || price <= 0) throw new Error('derived invalid');
    return price;
  } catch(e){ throw e; }
}
async function getTokenPriceUSD(address, decimals=18){
  if (!address) return null;
  const addr = low(address);
  const cached = priceCache.get(addr);
  if (cached && (nowTs() - cached.ts) < PRICE_TTL) {
    if (cached.price === null || cached.price === 0 || (Math.abs(cached.price) < 1e-18 && cached.price !== null)) {
    } else {
      return cached.price;
    }
  }
  try {
    const p1 = await fetch1InchQuotePrice(addr, decimals);
    if (p1 && Number.isFinite(p1) && p1 > 0) { priceCache.set(addr, {price:p1, ts:nowTs()}); return p1; }
  } catch(_) {}
  try {
    const cg = await fetchCoingeckoContractPrice(addr);
    if (cg && cg.price && Number.isFinite(cg.price) && cg.price > 0) { priceCache.set(addr, {price:cg.price, ts:nowTs()}); return cg.price; }
  } catch(_) {}
  try {
    const v = await fetchCoingeckoSimple(addr);
    if (v && Number.isFinite(v) && v > 0) { priceCache.set(addr, {price:v, ts:nowTs()}); return v; }
  } catch(_) {}
  try {
    const t = tokenMap.get(addr);
    if (t && t.symbol){
      const stat = cgStatsMap.get(low(t.symbol));
      if (stat && stat.price && Number.isFinite(stat.price) && stat.price > 0) { priceCache.set(addr, {price:stat.price, ts:nowTs()}); return stat.price; }
    }
  } catch(_) {}
  try {
    const d = await fetchDexscreenerPrice(addr);
    if (d && Number.isFinite(d) && d > 0) { priceCache.set(addr, {price:d, ts:nowTs()}); return d; }
  } catch(_) {}
  try {
    const derived = await derivePriceViaWeth(addr, decimals);
    if (derived && Number.isFinite(derived) && derived > 0) { priceCache.set(addr, {price:derived, ts:nowTs()}); return derived; }
  } catch(_) {}
  priceCache.set(addr, {price:null, ts:nowTs()});
  return null;
}

function makeSuggestionItem(tokenObj, stats, priceUSD){
  const row = document.createElement('div'); row.className='suggestion-item';
  const left = document.createElement('div'); left.className='suggestion-left';
  const img = document.createElement('img'); img.src = tokenObj.logoURI || (stats && stats.image) || DARK_SVG_PLACEHOLDER; img.onerror = ()=> img.src = DARK_SVG_PLACEHOLDER;
  img.style.width='28px'; img.style.height='28px'; img.style.borderRadius='50%';
  left.appendChild(img);
  const main = document.createElement('div'); main.className='suggestion-main';
  const sym = document.createElement('div'); sym.className='suggestion-symbol'; sym.textContent = tokenObj.symbol || (tokenObj.address?tokenObj.address.slice(0,6):'');
  const nm = document.createElement('div'); nm.className='suggestion-name'; nm.textContent = tokenObj.name || '';
  main.appendChild(sym); main.appendChild(nm);
  if (stats && typeof stats.change24h === 'number') {
    const ch = document.createElement('div'); ch.style.fontSize='11px'; ch.style.marginTop='6px'; ch.style.opacity='0.9';
    ch.textContent = (stats.change24h>=0?'+':'')+stats.change24h.toFixed(2)+'% (24h)';
    ch.style.color = stats.change24h >= 0 ? '#9ef39e' : '#ff9e9e';
    main.appendChild(ch);
  }
  left.appendChild(main);
  row.appendChild(left);
  const right = document.createElement('div'); right.className='suggestion-price-pill';
  if (priceUSD != null && Number.isFinite(priceUSD)) right.textContent = formatUSD(priceUSD);
  else right.textContent = '—';
  row.appendChild(right);
  return row;
}

function showDefaultList(side){
  const box = (side === 'from') ? fromSuggestions : toSuggestions;
  box.innerHTML = '';
  const candidates = tokenList.filter(t => { const s = low(t.symbol), n = low(t.name); return cgStatsMap.has(s) || cgStatsMap.has(n); });
  const withStats = candidates.map(t => { const s = low(t.symbol), n = low(t.name); const stat = cgStatsMap.get(s) || cgStatsMap.get(n) || {price:null,change24h:null,volume24h:0,image:''}; return {t,stat}; });
  withStats.sort((a,b)=> (b.stat.volume24h||0) - (a.stat.volume24h||0));
  const top = withStats.slice(0, Math.min(15, withStats.length));
  (async ()=>{
    for (const e of top){
      const tk = e.t, stats = e.stat;
      const price = stats.price ?? await getTokenPriceUSD(tk.address, tk.decimals);
      const node = makeSuggestionItem(tk, {change24h: stats.change24h ?? null, image: tk.logoURI || stats.image}, price);
      node.addEventListener('click', ()=>{ applyTokenSelection((side==='from')?'from':'to', tk); box.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd((side==='from')?fromTokenInput:toTokenInput); });
      box.appendChild(node);
    }
    box.style.display = top.length ? 'block' : 'none';
  })();
}

function setupAutocomplete(inputEl, boxEl, side){
  let timer = null;
  inputEl.addEventListener('input', ()=>{ clearTimeout(timer); timer = setTimeout(()=> handle(inputEl.value.trim().toLowerCase()), 140); });
  inputEl.addEventListener('focus', ()=> { const q = inputEl.value.trim().toLowerCase(); if (!q) showDefaultList(side); else handle(q); placeCaretAtEnd(inputEl); });
  inputEl.addEventListener('blur', ()=> setTimeout(()=> { boxEl.style.display='none'; }, 160));

  async function handle(q){
    boxEl.innerHTML = ''; if (!q){ boxEl.style.display='none'; return; }
    if (isAddress(q)){
      let info = tokenMap.get(low(q));
      if (!info) info = await fetchOnchainTokenInfo(q);
      if (info){
        const stat = cgStatsMap.get(low(info.symbol)) || cgStatsMap.get(low(info.name)) || null;
        const price = stat?.price ?? await getTokenPriceUSD(info.address, info.decimals);
        const node = makeSuggestionItem(info, {change24h: stat?.change24h ?? null, image: info.logoURI}, price);
        node.addEventListener('click', ()=>{ applyTokenSelection(side, info); boxEl.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd(inputEl); });
        boxEl.appendChild(node); boxEl.style.display='block';
      }
      return;
    }

    if (suggestionCache.has(q)){ renderSuggestionsFromCache(q, side, boxEl); return; }
    await ensureTokensLoaded();

    const matches = tokenList.filter(t => {
      const s = t.symbol || '', n = t.name || '';
      return (s.toLowerCase().includes(q) || n.toLowerCase().includes(q));
    });

    const cgMatches = matches.filter(t => cgStatsMap.has(low(t.symbol)) || cgStatsMap.has(low(t.name)))
      .map(t => {
        const stats = cgStatsMap.get(low(t.symbol)) || cgStatsMap.get(low(t.name)) || {volume24h:0,volume12h:null,price:null,change24h:null,image:''};
        const startBonus = ((t.symbol && t.symbol.toLowerCase().startsWith(q)) || (t.name && t.name.toLowerCase().startsWith(q))) ? 1e12 : 0;
        const v24 = stats.volume24h || 0;
        const v12 = stats.volume12h || 0;
        const score = v24 + (v12 * 1.2) + startBonus;
        return {t, stats, score};
      });
    cgMatches.sort((a,b)=> b.score - a.score);

    const inchMatches = matches.filter(t => {
      const s = t.symbol || '', n = t.name || '';
      const hasCG = cgStatsMap.has(low(s)) || cgStatsMap.has(low(n));
      return !hasCG && (s.toLowerCase().includes(q) || n.toLowerCase().includes(q));
    }).map(t => { const startBonus = ((t.symbol && t.symbol.toLowerCase().startsWith(q)) || (t.name && t.name.toLowerCase().startsWith(q))) ? 1e10 : 0; return {t,stats:null,score:startBonus}; })
      .sort((a,b)=> b.score - a.score);

    const merged = cgMatches.concat(inchMatches).slice(0, SUGGEST_LIMIT);
    const cacheResult = merged.map(x => ({ address: x.t.address, symbol: x.t.symbol, name: x.t.name, logoURI: x.t.logoURI, score: x.score }));
    suggestionCache.set(q, cacheResult);

    for (const s of merged){
      const tk = s.t;
      const stats = s.stats || {change24h:null,image: tk.logoURI||''};
      (async ()=>{
        const price = (s.stats && s.stats.price) ? s.stats.price : await getTokenPriceUSD(tk.address, tk.decimals);
        const node = makeSuggestionItem(tk, {change24h: stats.change24h ?? null, image: tk.logoURI || ''}, price);
        node.addEventListener('click', ()=>{ applyTokenSelection(side, tk); boxEl.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd(inputEl); });
        boxEl.appendChild(node);
      })();
    }
    boxEl.style.display = merged.length ? 'block' : 'none';
  }
}
function renderSuggestionsFromCache(q, side, box){
  const cached = suggestionCache.get(q) || [];
  box.innerHTML = '';
  (async ()=>{
    for (const item of cached.slice(0,SUGGEST_LIMIT)){
      const tk = tokenMap.get(low(item.address)) || { address: item.address, symbol: item.symbol, name: item.name, logoURI: item.logoURI };
      const stats = cgStatsMap.get(low(tk.symbol)) || cgStatsMap.get(low(tk.name)) || null;
      const price = await getTokenPriceUSD(tk.address, tk.decimals || 18);
      const node = makeSuggestionItem(tk, {change24h: stats?.change24h ?? null, image: tk.logoURI || stats?.image}, price);
      node.addEventListener('click', ()=>{ applyTokenSelection(side, tk); box.style.display='none'; updateEstimate(); scheduleActivePriceRefresh(); focusAndPlaceCaretAtEnd((side==='from')?fromTokenInput:toTokenInput); });
      box.appendChild(node);
    }
    box.style.display = cached.length ? 'block' : 'none';
  })();
}

setupAutocomplete(fromTokenInput, fromSuggestions, 'from');
setupAutocomplete(toTokenInput, toSuggestions, 'to');

function applyTokenSelection(side, tokenObj){
  if (!tokenObj) return;
  const input = (side === 'from') ? fromTokenInput : toTokenInput;
  const logo = (side === 'from') ? fromLogo : toLogo;
  const chip = (side === 'from') ? fromChip : toChip;
  const box = (side === 'from') ? fromBox : toBox;
  input.value = tokenObj.symbol || tokenObj.name || '';
  if (tokenObj.address) input.dataset.address = low(tokenObj.address);
  input.dataset.decimals = tokenObj.decimals || 18;
  if (tokenObj.logoURI){ logo.src = tokenObj.logoURI; logo.style.display = 'block'; } else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'block'; }
  tokenMap.set(tokenObj.address, tokenObj);
  box.classList.add('has-token');
  const imgUrl = tokenObj.logoURI ? `url('${tokenObj.logoURI}')` : 'none';
  box.style.setProperty('--token-icon-bg', imgUrl);
  ACTIVE_PRICE_ADDRS.add(low(tokenObj.address));
  chip.textContent = tokenObj.symbol || tokenObj.name || '';
  chip.style.display = 'inline-flex';
  focusAndPlaceCaretAtEnd(input);
  fetchPriceForToken(tokenObj.address, tokenObj.decimals || 18, side);
}
function clearTokenSelection(side){
  const box = (side === 'from') ? fromBox : toBox;
  box.classList.remove('has-token');
  box.style.removeProperty('--token-icon-bg');
  const chip = (side === 'from') ? fromChip : toChip;
  chip.style.display = 'none';
}

document.querySelectorAll('.input-box input[type="text"], .input-box input[type="number"]').forEach(inp=>{
  inp.addEventListener('paste', (ev)=>{
    const txt = (ev.clipboardData || window.clipboardData).getData('text').trim();
    if (isAddress(txt)) {
      setTimeout(async ()=> {
        inp.dataset.address = low(txt);
        let info = tokenMap.get(low(txt)) || await fetchOnchainTokenInfo(txt);
        if (info) {
          inp.dataset.decimals = info.decimals || 18;
          inp.value = info.symbol || info.name || txt.slice(0,8);
          tokenMap.set(info.address, info);
          const logo = (inp.id === 'fromToken') ? fromLogo : toLogo;
          const chip = (inp.id === 'fromToken') ? fromChip : toChip;
          if (info.logoURI) { logo.src = info.logoURI; logo.style.display = 'block'; } else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'block'; }
          const box = (inp.id === 'fromToken') ? fromBox : toBox;
          box.classList.add('has-token'); box.style.setProperty('--token-icon-bg', info.logoURI ? `url('${info.logoURI}')` : 'none');
          chip.textContent = info.symbol || info.name || '';
          chip.style.display = 'inline-flex';
          updateUsdVisibility();
          fetchBothPrices(); updateQuoteDebounced(); updateEstimate();
        }
      }, 10);
    }
  });
});

async function fetchOnchainTokenInfo(address){
  try {
    const addrL = low(address);
    if (tokenMap.has(addrL)) return tokenMap.get(addrL);
    const rpcProvider = new ethers.providers.JsonRpcProvider(FALLBACK_RPC);
    const abi = ["function symbol() view returns (string)","function name() view returns (string)","function decimals() view returns (uint8)"];
    const c = new ethers.Contract(address, abi, rpcProvider);
    const [symbol,name,decimals] = await Promise.all([ c.symbol().catch(()=>null), c.name().catch(()=>null), c.decimals().catch(()=>18) ]);
    const info = { address: addrL, symbol: symbol||address.slice(0,6), name: name||symbol||address.slice(0,8), decimals: decimals||18, logoURI: '' };
    tokenMap.set(info.address, info);
    if (!tokenList.find(t => t.address === info.address)) tokenList.push(info);
    return info;
  } catch(e){ console.warn('fetchOnchainTokenInfo failed', e); return null; }
}

async function fetchPriceForToken(address, decimals, side){
  try {
    if (!address) return;
    const price = await getTokenPriceUSD(address, decimals);
    const usdEl = (side === 'from') ? fromUsd : toUsd;
    const amtEl = (side === 'from') ? fromAmountEl : toAmountEl;
    const amt = Number(amtEl.value || 0);
    if (price != null && !Number.isNaN(amt) && amt>0) {
      usdEl.textContent = '≈ ' + formatUSD(Number(price) * amt);
    } else if (price != null) {
      usdEl.textContent = `${formatUSD(price)} / unit`;
    } else {
      usdEl.textContent = '—';
    }
    usdEl.style.display = price != null ? 'block' : 'none';
  } catch(e){ console.warn('fetchPriceForToken error', e); }
}
async function fetchBothPrices(){
  const fAddr = low(fromTokenInput.dataset.address || '');
  const tAddr = low(toTokenInput.dataset.address || '');
  const fDec = Number(fromTokenInput.dataset.decimals || 18);
  const tDec = Number(toTokenInput.dataset.decimals || 18);
  await Promise.all([
    fAddr ? fetchPriceForToken(fAddr, fDec, 'from') : Promise.resolve(),
    tAddr ? fetchPriceForToken(tAddr, tDec, 'to') : Promise.resolve()
  ]);
}

let quoteTimer = null;
function updateQuoteDebounced(){ clearTimeout(quoteTimer); quoteTimer = setTimeout(()=> updateQuote(), 140); }
async function updateQuote(){
  try {
    const fromAddr = low(fromTokenInput.dataset.address || '');
    const toAddr = low(toTokenInput.dataset.address || '');
    const amount = fromAmountEl.value;
    if (!fromAddr || !toAddr || !amount) { await fetchBothPrices(); return; }
    const fromDecimals = Number(fromTokenInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const toDecimals = Number(toTokenInput.dataset.decimals || tokenMap.get(toAddr)?.decimals || 18);
    const parsed = ethers.utils.parseUnits(String(amount), fromDecimals).toString();
    const quoteUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${parsed}`;
    const r = await fetchWithTimeout(quoteUrl, {}, 3000);
    const j = await r.json();
    if (j && j.toTokenAmount) {
      const formattedTo = ethers.utils.formatUnits(ethers.BigNumber.from(j.toTokenAmount), toDecimals);
      toAmountEl.value = formattedTo;
    }
    await fetchBothPrices();
  } catch (e) {
    console.warn('updateQuote error (1inch)', e);
    await fetchBothPrices();
  }
}
fromAmountEl.addEventListener('input', ()=>{ updateQuoteDebounced(); updateEstimate(); });

async function updateEstimate(){
  try {
    await ensureTokensLoaded();
    resolveTokenInputsIfNeeded();
    const fromAddr = low(fromTokenInput.dataset.address || '');
    const toAddr = low(toTokenInput.dataset.address || '');
    const fromAmount = Number(fromAmountEl.value || 0);
    if (!fromAddr || !toAddr || !fromAmount || Number.isNaN(fromAmount) || fromAmount <= 0) return;
    const fDec = Number(fromTokenInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
    const tDec = Number(toTokenInput.dataset.decimals || tokenMap.get(toAddr)?.decimals || 18);
    const [fromPrice, toPrice] = await Promise.all([ getTokenPriceUSD(fromAddr, fDec), getTokenPriceUSD(toAddr, tDec) ]);
    if (!fromPrice || !toPrice) return;
    const fromUSD = Number(fromAmount) * Number(fromPrice);
    const estimatedTo = fromUSD / Number(toPrice);
    const display = (Number.isFinite(estimatedTo)) ? Number(estimatedTo.toFixed(6)).toString() : '';
    toAmountEl.value = display;
    fromUsd.style.display = 'block';
    toUsd.style.display = 'block';
    fromUsd.textContent = `≈ ${formatUSD(fromUSD)}`;
    toUsd.textContent = `${formatUSD(toPrice)} / unit`;
  } catch(e){ console.warn('updateEstimate error', e); }
}

function resolveTokenInputsIfNeeded(){
  const tryResolve = (inputEl) => {
    const val = (inputEl.value || '').trim(); if (!val || inputEl.dataset.address) return;
    const q = val.toLowerCase();
    let found = tokenList.find(t => t.symbol && t.symbol.toLowerCase() === q && (cgStatsMap.has(low(t.symbol)) || cgStatsMap.has(low(t.name))));
    if (!found) found = tokenList.find(t => t.symbol && t.symbol.toLowerCase() === q);
    if (!found) found = tokenList.find(t => t.symbol && t.symbol.toLowerCase().startsWith(q));
    if (!found) found = tokenList.find(t => t.name && t.name.toLowerCase().includes(q));
    if (found){ inputEl.dataset.address = found.address; inputEl.dataset.decimals = found.decimals || 18; const logo = (inputEl.id === 'fromToken')? fromLogo : toLogo; const chip = (inputEl.id === 'fromToken')? fromChip : toChip; if (found.logoURI){ logo.src = found.logoURI; logo.style.display = 'block'; } else { logo.src = DARK_SVG_PLACEHOLDER; logo.style.display = 'block'; } const box = (inputEl.id === 'fromToken')? fromBox : toBox; box.classList.add('has-token'); box.style.setProperty('--token-icon-bg', found.logoURI ? `url('${found.logoURI}')` : 'none'); ACTIVE_PRICE_ADDRS.add(found.address); chip.textContent = found.symbol || found.name || ''; chip.style.display = 'inline-flex'; }
  };
  tryResolve(fromTokenInput); tryResolve(toTokenInput);
}

/* swapOutside behavior moved but id preserved earlier; handler kept identical */
swapOutside.addEventListener('click', ()=>{
  swapOutside.classList.add('pressed');
  setTimeout(()=> swapOutside.classList.remove('pressed'), 300);
  const fVal = fromTokenInput.value, tVal = toTokenInput.value;
  const fAddr = fromTokenInput.dataset.address, tAddr = toTokenInput.dataset.address;
  const fDec = fromTokenInput.dataset.decimals, tDec = toTokenInput.dataset.decimals;
  const fLogo = fromLogo.src, tLogoSrc = toLogo.src;
  const aFrom = fromAmountEl.value, aTo = toAmountEl.value;
  fromTokenInput.value = tVal; toTokenInput.value = fVal;
  if (tAddr) fromTokenInput.dataset.address = tAddr; else delete fromTokenInput.dataset.address;
  if (fAddr) toTokenInput.dataset.address = fAddr; else delete toTokenInput.dataset.address;
  if (tDec) fromTokenInput.dataset.decimals = tDec; else delete fromTokenInput.dataset.decimals;
  if (fDec) toTokenInput.dataset.decimals = fDec; else delete toTokenInput.dataset.decimals;
  fromLogo.src = tLogoSrc || ''; fromLogo.style.display = tLogoSrc ? 'block' : 'none';
  toLogo.src = fLogo || ''; toLogo.style.display = fLogo ? 'block' : 'none';
  fromAmountEl.value = aTo; toAmountEl.value = aFrom;
  if (fromTokenInput.dataset.address) fromBox.classList.add('has-token'); else fromBox.classList.remove('has-token');
  if (toTokenInput.dataset.address) toBox.classList.add('has-token'); else toBox.classList.remove('has-token');
  try{ typeof updateQuoteDebounced === 'function' && updateQuoteDebounced(); }catch(e){}
  try{ typeof fetchBothPrices === 'function' && fetchBothPrices(); }catch(e){}
  try{ typeof updateEstimate === 'function' && updateEstimate(); }catch(e){}
});

/* swapBtn kept as simple placeholder */
swapBtn.addEventListener('click', ()=> {
  alert('To run a swap: connect wallet via the Connect Wallet button (top-right).');
});

/* wallet connect (identical) */
let provider = null, signer = null, userAddress = null, web3modal = null;
async function initWeb3Modal(){
  try{ web3modal = new window.WalletConnectWeb3Modal.default({ projectId: WALLETCONNECT_PROJECT_ID, themeMode: 'dark' }); }catch(e){ console.warn('web3modal init', e); web3modal = null; }
}
initWeb3Modal();

async function connectWallet(){
  try{
    if (window.ethereum && window.ethereum.isMetaMask){
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send('eth_requestAccounts', []);
      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      addrChip.style.display = 'inline-block';
      addrChip.textContent = `${userAddress.slice(0,6)}…${userAddress.slice(-4)}`;
      return true;
    }
    if (web3modal && WALLETCONNECT_PROJECT_ID && WALLETCONNECT_PROJECT_ID !== 'WALLETCONNECT_PROJECT_ID'){
      const wc = await web3modal.openModal();
      if(!wc) return false;
      provider = new ethers.providers.Web3Provider(wc);
      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      addrChip.style.display = 'inline-block';
      addrChip.textContent = `${userAddress.slice(0,6)}…${userAddress.slice(-4)}`;
      return true;
    }
    alert('No wallet found. Install MetaMask or configure WalletConnect Project ID.');
    return false;
  } catch(e){
    console.error('connect error', e);
    alert('Wallet connection failed: ' + (e.message || e));
    return false;
  }
}
connectFloating.addEventListener('click', connectWallet);

/* Background refresh and active price refresh (identical) */
async function refreshCoinGeckoMarkets(){
  try {
    const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`;
    const rm = await fetchWithTimeout(marketsUrl, {}, 4000);
    if (!rm.ok) throw new Error('CG markets refresh failed');
    const jm = await rm.json();
    jm.forEach(c => {
      const sym = low(c.symbol||''), name = low(c.name||'');
      const stat = { price: (typeof c.current_price === 'number' ? c.current_price : null), change24h: (typeof c.price_change_percentage_24h === 'number' ? c.price_change_percentage_24h : null), volume24h: (typeof c.total_volume === 'number' ? c.total_volume : 0), image: c.image||'', volume12h: null };
      if (sym) cgStatsMap.set(sym, stat);
      if (name) cgStatsMap.set(name, stat);
      tokenList.forEach(t => { if (t.symbol && low(t.symbol) === sym) priceCache.set(t.address, { price: stat.price, ts: nowTs() }); });
    });
    fetchBothPrices();
    updateEstimate();
    updateUsdVisibility();
  } catch(e){ console.warn('refreshCoinGeckoMarkets error', e); }
}
let refreshInterval = null;
function startBackgroundRefresh(){
  if (refreshInterval) clearInterval(refreshInterval);
  refreshCoinGeckoMarkets();
  refreshInterval = setInterval(refreshCoinGeckoMarkets, 7000);
}
let activePriceInterval = null;
function scheduleActivePriceRefresh(){
  updateUsdVisibility();
  if (activePriceInterval) return;
  (async()=>{
    await refreshActivePrices();
    activePriceInterval = setInterval(refreshActivePrices, 7000);
  })();
}
async function refreshActivePrices(){
  const addrs = Array.from(ACTIVE_PRICE_ADDRS).filter(a => a && a.length === 42);
  if (!addrs.length) return;
  await Promise.all(addrs.map(async addr => {
    const decimals = tokenMap.get(addr)?.decimals || 18;
    const price = await getTokenPriceUSD(addr, decimals);
    if (addr === low(fromTokenInput.dataset.address || '')) fetchPriceForToken(addr, decimals, 'from');
    if (addr === low(toTokenInput.dataset.address || '')) fetchPriceForToken(addr, decimals, 'to');
  }));
}

function updateUsdVisibility(){
  if (!fromTokenInput.dataset.address) { fromUsd.style.display = 'none'; ACTIVE_PRICE_ADDRS.delete(low(fromTokenInput.dataset.address||'')); } else { fromUsd.style.display = 'block'; ACTIVE_PRICE_ADDRS.add(low(fromTokenInput.dataset.address||'')); }
  if (!toTokenInput.dataset.address) { toUsd.style.display = 'none'; ACTIVE_PRICE_ADDRS.delete(low(toTokenInput.dataset.address||'')); } else { toUsd.style.display = 'block'; ACTIVE_PRICE_ADDRS.add(low(toTokenInput.dataset.address||'')); }
}

/* hide suggestions on outside click & esc */
document.addEventListener('click', (ev)=>{
  const inInputOrSuggest = ev.target.closest('.input-box') || ev.target.closest('.suggestions') || ev.target.closest('#fromToken') || ev.target.closest('#toToken') || ev.target.closest('.slippage-wrap');
  if (!inInputOrSuggest){
    fromSuggestions.style.display = 'none';
    toSuggestions.style.display = 'none';
  }
});
document.addEventListener('keydown', (ev)=>{ if (ev.key === 'Escape'){ fromSuggestions.style.display='none'; toSuggestions.style.display='none'; } });

/* caret helpers and clickable left area */
function placeCaretAtEnd(inputEl){
  try{ const len = (inputEl.value || '').length; inputEl.setSelectionRange(len, len); }catch(e){}
}
function focusAndPlaceCaretAtEnd(inputEl){ try{ inputEl.focus(); placeCaretAtEnd(inputEl); }catch(e){} }

fromBox.querySelector('.left').addEventListener('click', (e)=>{
  if (e.target.closest('.suggestions') || e.target.closest('input[type="number"]')) return;
  focusAndPlaceCaretAtEnd(fromTokenInput);
  showDefaultList('from');
});
toBox.querySelector('.left').addEventListener('click', (e)=>{
  if (e.target.closest('.suggestions') || e.target.closest('input[type="number"]')) return;
  focusAndPlaceCaretAtEnd(toTokenInput);
  showDefaultList('to');
});

/* INIT logic (unchanged) */
(async function init(){
  await ensureTokensLoaded();
  const usdc = tokenList.find(t => t.address && t.address.toLowerCase() === USDC_ADDR.toLowerCase());
  if (usdc) {
    fromTokenInput.value = usdc.symbol || 'USDC';
    fromTokenInput.dataset.address = usdc.address;
    fromTokenInput.dataset.decimals = usdc.decimals || 6;
    if (usdc.logoURI){ fromLogo.src = usdc.logoURI; fromLogo.style.display='block'; }
    ACTIVE_PRICE_ADDRS.add(low(usdc.address));
    fromChip.textContent = usdc.symbol || 'USDC'; fromChip.style.display = 'inline-flex';
    fromBox.classList.add('has-token'); fromBox.style.setProperty('--token-icon-bg', usdc.logoURI ? `url('${usdc.logoURI}')` : 'none');
  }
  const top = tokenList.find(t => cgStatsMap.has(low(t.symbol)));
  if (top) {
    toTokenInput.value = top.symbol || top.name;
    toTokenInput.dataset.address = top.address;
    toTokenInput.dataset.decimals = top.decimals || 18;
    if (top.logoURI){ toLogo.src = top.logoURI; toLogo.style.display='block'; }
    ACTIVE_PRICE_ADDRS.add(low(top.address));
    toChip.textContent = top.symbol || top.name; toChip.style.display = 'inline-flex';
    toBox.classList.add('has-token'); toBox.style.setProperty('--token-icon-bg', top.logoURI ? `url('${top.logoURI}')` : 'none');
  }
  updateUsdVisibility();
  fetchBothPrices();
  startBackgroundRefresh();
  scheduleActivePriceRefresh();
  // animate swapInside entrance
  setTimeout(()=> { swapOutside.classList.add('entered'); }, 200);
})();

/* slippage UI (keeps previous behavior) */
slippageSel.addEventListener('change', ()=>{
  if(slippageSel.value === 'custom'){ customSlippage.style.display = 'inline-block'; customSlippage.focus(); }
  else customSlippage.style.display = 'none';
});

/* expose functions for debugging */
window.getTokenPriceUSD = getTokenPriceUSD;
window.applyTokenSelection = applyTokenSelection;
window.clearTokenSelection = clearTokenSelection;
window.updateQuoteDebounced = updateQuoteDebounced;
window.fetchBothPrices = fetchBothPrices;
window.updateEstimate = updateEstimate;
window.scheduleActivePriceRefresh = scheduleActivePriceRefresh;

/* (END UNCHANGED BLOCK) */
</script>

</body>
</html>
