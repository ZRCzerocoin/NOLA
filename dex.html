<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NOLA Exchange</title>
<style>
/* ===== BASIC THEME ===== (unchanged) */
body {margin:0; padding:0; font-family:'Arial',sans-serif; background: radial-gradient(circle at center, #0c0014, #1a002b 80%); color:#fff;}
.container {width:90%; max-width:480px; margin:40px auto; background:rgba(255,255,255,0.05); border-radius:25px; padding:25px; backdrop-filter:blur(18px); box-shadow:0 0 25px rgba(180,0,255,0.3);}
h2{text-align:center; color:#e0b3ff; text-shadow:0 0 8px #b445ff;}
.input-box {margin-top:20px; padding:15px; background:rgba(255,255,255,0.05); border-radius:16px; position:relative;}
.input-box input{width:100%; padding:12px; border-radius:12px; border:none; background:rgba(255,255,255,0.05); color:#fff; font-size:16px;}
.suggestions { position:absolute; top:50px; left:0; width:100%; background:rgba(25,0,50,0.95); border-radius:12px; max-height:200px; overflow-y:auto; display:none; z-index:100; }
.suggestion-item { padding:10px; display:flex; align-items:center; cursor:pointer; justify-content:space-between; }
.suggestion-left { display:flex; align-items:center; gap:10px; }
.suggestion-left img { width:28px; height:28px; border-radius:8px; object-fit:cover; }
.suggestion-main { display:flex; flex-direction:column; }
.suggestion-symbol { font-weight:700; font-size:14px; }
.suggestion-name { font-size:12px; opacity:0.8; }
.suggestion-price { text-align:right; font-size:13px; opacity:0.9; }
.btn {width:100%; padding:14px; margin-top:20px; border:none; border-radius:20px; background: linear-gradient(135deg,#b445ff,#7013ff); color:#fff; font-size:18px; cursor:pointer;}
footer {text-align:center; margin:30px 0 10px 0; font-size:14px; opacity:0.8;}
footer a{color:#b445ff; text-decoration:none; margin:0 5px;}

/* Small added UI elements — kept subtle and aligned with theme */
#swapTokensBtn {
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  top:calc(50% - 20px);
  width:36px;
  height:36px;
  border-radius:50%;
  background:rgba(30,20,60,0.8);
  border:2px solid rgba(255,255,255,0.05);
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  font-size:16px;
  color:#fff;
  z-index:150;
}
#walletConnectBtn {
  position:fixed;
  top:16px;
  right:16px;
  padding:10px 14px;
  border:none;
  border-radius:14px;
  background: linear-gradient(135deg,#b445ff,#7013ff);
  color:#fff;
  cursor:pointer;
  z-index:999;
  font-weight:600;
}
/* global search small and compact */
#globalSearch {
  width:calc(100% - 30px);
  display:block;
  margin:10px auto 6px;
  padding:8px 10px;
  border-radius:10px;
  border:none;
  background:rgba(255,255,255,0.03);
  color:#fff;
  font-size:14px;
  outline:none;
}
/* small price tag inside suggestion */
.suggestion-small-price { font-size:12px; opacity:0.85; color:#dcd6ff; }
</style>
</head>
<body>

<button id="walletConnectBtn">Connect Wallet</button>

<div class="container">
    <h2>NOLA Exchange</h2>

    <!-- compact global search placed inside container, above From: small & professional -->
    <input id="globalSearch" placeholder="Search contract address or token (fills To)" autocomplete="off">

    <div class="input-box">
        <input type="text" id="fromToken" placeholder="From Token">
        <div class="suggestions" id="fromSuggestions"></div>
    </div>

    <div id="swapTokensBtn" title="Swap From ↔ To">⇅</div>

    <div class="input-box" style="margin-top:44px;">
        <input type="text" id="toToken" placeholder="To Token">
        <div class="suggestions" id="toSuggestions"></div>
    </div>

    <!-- amount inputs added minimal, placed under UI (no theme changes) -->
    <div style="margin-top:12px; display:flex; gap:8px;">
        <input id="fromAmount" type="number" placeholder="Amount" style="flex:1; padding:10px; border-radius:12px; border:none; background:rgba(255,255,255,0.05); color:#fff;">
        <input id="toAmount" type="number" placeholder="Estimated" readonly style="flex:1; padding:10px; border-radius:12px; border:none; background:rgba(255,255,255,0.05); color:#fff;">
    </div>

    <div style="margin-top:10px;">
        <select id="slippage" style="padding:8px; border-radius:10px; border:none; background:rgba(255,255,255,0.03); color:#fff;">
            <option value="0.1">0.1%</option>
            <option value="0.5">0.5%</option>
            <option value="1" selected>1%</option>
            <option value="2">2%</option>
        </select>
    </div>

    <button class="btn" id="swapBtn">Swap</button>
</div>

<footer>
&copy; 2025 NOLA | <a href="Terms.html">Privacy & Terms</a> | 
<a href="#" id="nolTokenLink">NOLA Token</a> | 
<a href="#" id="xLink">X</a> | 
<a href="#" id="telegramLink">Telegram</a>
</footer>

<!-- libraries -->
<script src="https://cdn.jsdelivr.net/npm/ethers/dist/ethers.min.js"></script>
<!-- WalletConnect v2 UMD -->
<script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider/dist/umd/index.min.js"></script>

<script>
/* ========= Configuration ========= */
const PROJECT_ID = "6557a92e3698182727669d41cbeb95a1"; // your WC v2 id
const CHAIN_ID = 137; // Polygon
const ONEINCH_BASE = `https://api.1inch.io/v5.0/${CHAIN_ID}`;
const COINGECKO_CHAIN = 'polygon-pos';
const FALLBACK_RPC = "https://polygon-rpc.com";

/* ========= State ========= */
let tokenList = []; // from coingecko token list
let tokenMap = new Map(); // addressLower -> tokenObj
let symbolVolumeMap = new Map(); // symbolLower -> 24h volume (from Coingecko markets)
let provider = null;
let signer = null;
let userAddress = null;
let walletConnected = false;

/* ========= Helpers ========= */
const $ = id => document.getElementById(id);
const isAddress = v => /^0x[a-fA-F0-9]{40}$/.test((v||'').trim());
const lower = s => (s||'').toLowerCase();
const MATIC_ADDR = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';

/* ========= Load tokens and market-volume ranking ========= */
async function loadTokensAndVolumes(){
    try {
        // 1) token list hosted (Coingecko polygon list includes decimals & logo)
        const r1 = await fetch('https://tokens.coingecko.com/polygon-pos/all.json');
        const j1 = await r1.json();
        tokenList = (j1.tokens || []).map(t => ({
            address: lower(t.address),
            symbol: t.symbol || '',
            name: t.name || '',
            decimals: t.decimals || 18,
            logoURI: t.logoURI || t.logo || ''
        }));
        tokenList.forEach(t => tokenMap.set(t.address, t));

        // include pseudo MATIC
        tokenMap.set(MATIC_ADDR, { address: MATIC_ADDR, symbol: 'MATIC', name:'Polygon', decimals:18, logoURI:'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/polygon/info/logo.png' });

        // 2) fetch top coins by 24h volume (Coingecko markets)
        // We'll fetch many pages to improve coverage (per_page 250). This returns symbol + total_volume.
        const marketsUrl = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=250&page=1&sparkline=false`;
        const r2 = await fetch(marketsUrl);
        const markets = await r2.json();
        // build symbol->volume map (lowercase)
        markets.forEach(c => {
            if (c.symbol) symbolVolumeMap.set(lower(c.symbol), c.total_volume || 0);
        });
    } catch (e) {
        console.error('loadTokensAndVolumes error', e);
    }
}
loadTokensAndVolumes();

/* ========= Utility: fetch token info from chain for unknown tokens ========= */
async function fetchOnchainTokenInfo(address){
    try {
        const rpcProvider = new ethers.providers.JsonRpcProvider(FALLBACK_RPC);
        const abi = ["function symbol() view returns (string)","function name() view returns (string)","function decimals() view returns (uint8)"];
        const c = new ethers.Contract(address, abi, rpcProvider);
        const [symbol, name, decimals] = await Promise.all([
            c.symbol().catch(()=>null),
            c.name().catch(()=>null),
            c.decimals().catch(()=>18)
        ]);
        return { address: lower(address), symbol: symbol || address.slice(0,6), name: name || symbol || address.slice(0,8), decimals: decimals || 18, logoURI: 'https://via.placeholder.com/28' };
    } catch (e) {
        console.warn('fetchOnchainTokenInfo failed', e);
        return null;
    }
}

/* ========= Price fetch helper (Coingecko simple/token_price polygon-pos) ========= */
async function fetchTokenPriceUSD(address){
    try {
        if (!address) return null;
        if (lower(address) === MATIC_ADDR) {
            const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=matic-network&vs_currencies=usd');
            const j = await r.json();
            return j['matic-network']?.usd ?? null;
        }
        const url = `https://api.coingecko.com/api/v3/simple/token_price/${COINGECKO_CHAIN}?contract_addresses=${address}&vs_currencies=usd`;
        const r = await fetch(url);
        const j = await r.json();
        const key = lower(address);
        return j[key]?.usd ?? null;
    } catch (e) {
        console.warn('price fetch failed', e);
        return null;
    }
}

/* ========= Autocomplete rendering (used for from/to and global search) ========= */
function makeSuggestionItem(tokenObj, approxPriceUSD, extraText){
    // tokenObj: {address,symbol,name,logoURI,decimals}
    const left = document.createElement('div');
    left.className = 'suggestion-left';
    const img = document.createElement('img');
    img.src = tokenObj.logoURI || 'https://via.placeholder.com/28';
    img.onerror = ()=>img.src='https://via.placeholder.com/28';
    left.appendChild(img);

    const main = document.createElement('div');
    main.className = 'suggestion-main';
    const sym = document.createElement('div');
    sym.className = 'suggestion-symbol';
    sym.textContent = `${tokenObj.symbol || tokenObj.address.slice(0,6)}`;
    const nm = document.createElement('div');
    nm.className = 'suggestion-name';
    nm.textContent = tokenObj.name || '';
    main.appendChild(sym);
    main.appendChild(nm);

    left.appendChild(main);

    const right = document.createElement('div');
    right.className = 'suggestion-price';
    if (approxPriceUSD != null) {
        right.innerHTML = `<div>${extraText || ''}</div><div style="margin-top:6px; font-weight:600;">≈ $${Number(approxPriceUSD).toFixed(4)}</div>`;
    } else {
        right.innerHTML = `<div>${extraText || ''}</div><div style="margin-top:6px; opacity:0.8">—</div>`;
    }

    const row = document.createElement('div');
    row.className = 'suggestion-item';
    row.appendChild(left);
    row.appendChild(right);
    return row;
}

/* ========= Setup autocomplete for from/to inputs ========= */
function setupAutocomplete(inputId, suggestionsId){
    const input = $(inputId);
    const box = $(suggestionsId);

    let timer = null;
    input.addEventListener('input', ()=> {
        clearTimeout(timer);
        timer = setTimeout(()=> handle(input.value.trim().toLowerCase()), 120);
    });
    input.addEventListener('focus', ()=> {
        if (input.value.trim()) handle(input.value.trim().toLowerCase());
    });
    input.addEventListener('blur', ()=> setTimeout(()=> box.style.display='none', 150));

    async function handle(q){
        box.innerHTML = '';
        if (!q) { box.style.display='none'; return; }

        // gather matches: find tokens where symbol OR name includes q
        const matches = tokenList.filter(t => {
            const sym = t.symbol || '';
            const name = t.name || '';
            return sym.toLowerCase().includes(q) || name.toLowerCase().includes(q);
        });

        // If nothing matched in tokenList and q looks like address -> attempt onchain fetch
        if (!matches.length && isAddress(q)) {
            let info = tokenMap.get(lower(q));
            if (!info) {
                info = await fetchOnchainTokenInfo(q);
                if (info) {
                    tokenMap.set(lower(q), info);
                }
            }
            if (info) {
                const price = await fetchTokenPriceUSD(info.address);
                const item = makeSuggestionItem(info, price, '');
                item.onclick = ()=>{
                    input.value = info.symbol || info.name;
                    input.dataset.address = info.address;
                    input.dataset.decimals = info.decimals;
                    box.style.display='none';
                    // trigger live update if from or to changed
                    if (inputId === 'fromToken' || inputId === 'toToken') updateQuoteDebounced();
                };
                box.appendChild(item);
                box.style.display='block';
            }
            return;
        }

        // compute volume score for each match using symbolVolumeMap; fallback zero
        const scored = matches.map(t => {
            const vol = symbolVolumeMap.get(lower(t.symbol)) || 0;
            // bias matches that startWith query
            const startBonus = (t.symbol.toLowerCase().startsWith(q) || t.name.toLowerCase().startsWith(q)) ? 1e12 : 0;
            return { t, score: vol + startBonus };
        });

        // sort by score desc
        scored.sort((a,b)=> b.score - a.score);

        // show top 8
        const top = scored.slice(0,8);
        for (const s of top) {
            const tk = s.t;
            const price = await fetchTokenPriceUSD(tk.address);
            const extraText = `${tk.symbol} | ${tk.name}`;
            const node = makeSuggestionItem(tk, price, extraText);
            node.onclick = ()=>{
                input.value = tk.symbol || tk.name;
                input.dataset.address = tk.address;
                input.dataset.decimals = tk.decimals || 18;
                box.style.display='none';
                // when selecting, update quote if needed
                updateQuoteDebounced();
            };
            box.appendChild(node);
        }
        box.style.display = top.length ? 'block' : 'none';
    }
}

setupAutocomplete('fromToken','fromSuggestions');
setupAutocomplete('toToken','toSuggestions');

/* ========= Global search (compact) - shows suggestions same style, fills To ========= */
const globalSearch = $('globalSearch');
let globalTimer = null;
globalSearch.addEventListener('input', ()=> {
    clearTimeout(globalTimer);
    globalTimer = setTimeout(()=> handleGlobal(globalSearch.value.trim()), 140);
});

const globalBox = document.createElement('div');
globalBox.className = 'suggestions';
globalBox.style.position = 'absolute';
globalBox.style.top = (globalSearch.getBoundingClientRect().top + 46) + 'px';
globalBox.style.left = globalSearch.offsetLeft + 'px';
globalBox.style.width = (globalSearch.offsetWidth) + 'px';
globalBox.style.zIndex = 200;
globalSearch.parentElement.insertBefore(globalBox, globalSearch.nextSibling);
globalSearch.addEventListener('blur', ()=> setTimeout(()=> globalBox.style.display='none', 150));

async function handleGlobal(q){
    globalBox.innerHTML = '';
    if (!q) { globalBox.style.display='none'; return; }

    // If address -> try token info and display single suggestion
    if (isAddress(q)) {
        let info = tokenMap.get(lower(q));
        if (!info) {
            info = await fetchOnchainTokenInfo(q);
            if (info) tokenMap.set(info.address, info);
        }
        if (info) {
            const price = await fetchTokenPriceUSD(info.address);
            const node = makeSuggestionItem(info, price, `${info.symbol}`);
            node.onclick = ()=>{
                // fill To
                const to = $('toToken');
                to.value = info.symbol || info.name;
                to.dataset.address = info.address;
                to.dataset.decimals = info.decimals || 18;
                globalBox.style.display='none';
                // update price & quote
                updateQuoteDebounced();
            };
            globalBox.appendChild(node);
            globalBox.style.display='block';
        }
        return;
    }

    // Not an address: search tokenList by name/symbol
    const matches = tokenList.filter(t => (t.symbol && t.symbol.toLowerCase().includes(q)) || (t.name && t.name.toLowerCase().includes(q)));
    // score by 24h volume
    const scored = matches.map(t => {
        const vol = symbolVolumeMap.get(lower(t.symbol)) || 0;
        const startBonus = (t.symbol.toLowerCase().startsWith(q) || t.name.toLowerCase().startsWith(q)) ? 1e12 : 0;
        return { t, score: vol + startBonus };
    }).sort((a,b)=> b.score - a.score).slice(0,8);

    for (const s of scored) {
        const tk = s.t;
        const price = await fetchTokenPriceUSD(tk.address);
        const node = makeSuggestionItem(tk, price, `${tk.symbol}`);
        node.onclick = ()=>{
            const to = $('toToken');
            to.value = tk.symbol;
            to.dataset.address = tk.address;
            to.dataset.decimals = tk.decimals || 18;
            globalBox.style.display='none';
            updateQuoteDebounced();
        };
        globalBox.appendChild(node);
    }
    globalBox.style.display = scored.length ? 'block' : 'none';
}

/* ========= Wallet connect v2 (works across browsers/devices) ========= */
async function connectWallet(){
    if (walletConnected && signer) return;
    try {
        // prefer injected
        if (window.ethereum && window.ethereum.isMetaMask) {
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            await provider.send("eth_requestAccounts", []);
            signer = provider.getSigner();
            userAddress = await signer.getAddress();
            walletConnected = true;
            $('walletConnectBtn').textContent = 'Connected';
            return;
        }

        // WalletConnect v2 UMD global: window.WalletConnectProvider
        const WalletConnectProvider = window.WalletConnectProvider;
        if (!WalletConnectProvider || !WalletConnectProvider.init) {
            alert('WalletConnect v2 library not loaded');
            throw new Error('WC v2 lib missing');
        }

        const wcProvider = await WalletConnectProvider.init({
            projectId: PROJECT_ID,
            chains: [CHAIN_ID],
            showQrModal: true,
            // optional metadata can be added here
        });

        // enable (opens modal / deep link)
        await wcProvider.enable();

        provider = new ethers.providers.Web3Provider(wcProvider, "any");
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        walletConnected = true;
        $('walletConnectBtn').textContent = 'Connected';

        // handle disconnect event
        wcProvider.on?.('disconnect', ()=> {
            walletConnected = false;
            signer = null;
            provider = null;
            userAddress = null;
            $('walletConnectBtn').textContent = 'Connect Wallet';
        });

    } catch (e) {
        console.error('connectWallet error', e);
        alert('Wallet connect failed: ' + (e.message || e));
        throw e;
    }
}

$('walletConnectBtn').addEventListener('click', connectWallet);

/* ========= Quote logic (1inch) ========= */
let quoteTimer = null;
function updateQuoteDebounced(){
    clearTimeout(quoteTimer);
    quoteTimer = setTimeout(()=> updateQuote(), 220);
}
async function updateQuote(){
    try {
        const fromInput = $('fromToken');
        const toInput = $('toToken');
        const fromAmtInput = $('fromAmount');
        const toAmtInput = $('toAmount');

        const fromAddr = fromInput.dataset.address;
        const toAddr = toInput.dataset.address;
        const amount = fromAmtInput.value;
        if (!fromAddr || !toAddr || !amount) { toAmtInput.value=''; return; }

        const fromDecimals = Number(fromInput.dataset.decimals || tokenMap.get(lower(fromAddr))?.decimals || 18);
        const toDecimals = Number(toInput.dataset.decimals || tokenMap.get(lower(toAddr))?.decimals || 18);

        const parsed = ethers.utils.parseUnits(String(amount), fromDecimals).toString();
        const quoteUrl = `${ONEINCH_BASE}/quote?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${parsed}`;
        const r = await fetch(quoteUrl);
        const j = await r.json();
        if (j && j.toTokenAmount) {
            toAmtInput.value = ethers.utils.formatUnits(j.toTokenAmount, toDecimals);
        } else {
            toAmtInput.value = '';
        }
    } catch (e) {
        console.error('updateQuote error', e);
        $('toAmount').value = '';
    }
}

/* attach inputs to quote updates */
$('fromAmount').addEventListener('input', updateQuoteDebounced);

/* When user selects token via the from/to autocompletes, updateQuoteDebounced(); handled in selection callbacks */

/* ========= Allowance / approve / swap flow using 1inch ========= */
async function ensureApprovalAndSwap(){
    try {
        // ensure connected
        await connectWallet();

        const fromInput = $('fromToken');
        const toInput = $('toToken');
        const amountInput = $('fromAmount').value;
        const slippage = $('slippage')?.value || 1;

        if (!fromInput.dataset.address || !toInput.dataset.address || !amountInput) {
            alert('Please select tokens and amount.');
            return;
        }

        const fromAddr = lower(fromInput.dataset.address);
        const toAddr = lower(toInput.dataset.address);
        const fromDecimals = Number(fromInput.dataset.decimals || tokenMap.get(fromAddr)?.decimals || 18);
        const parsedAmount = ethers.utils.parseUnits(String(amountInput), fromDecimals).toString();

        // if from is not native, check allowance
        if (fromAddr !== MATIC_ADDR) {
            // get allowance from 1inch
            const allowanceUrl = `${ONEINCH_BASE}/approve/allowance?tokenAddress=${fromAddr}&walletAddress=${userAddress}`;
            const ar = await fetch(allowanceUrl);
            const allowanceJ = await ar.json();
            const allowance = allowanceJ.allowance ? ethers.BigNumber.from(allowanceJ.allowance) : ethers.BigNumber.from('0');

            if (allowance.lt(ethers.BigNumber.from(parsedAmount))) {
                // request approve tx data
                const approveTxUrl = `${ONEINCH_BASE}/approve/transaction?tokenAddress=${fromAddr}`;
                const apr = await fetch(approveTxUrl);
                const aprJson = await apr.json();
                if (!aprJson || !aprJson.data) throw new Error('Approve data not available');

                // send approval transaction
                const txReq = { to: aprJson.to, data: aprJson.data, value: aprJson.value ? ethers.BigNumber.from(aprJson.value) : undefined };
                const sent = await signer.sendTransaction(txReq);
                alert('Approval sent, waiting confirmation: ' + sent.hash);
                await sent.wait();
            }
        }

        // build swap
        const swapUrl = `${ONEINCH_BASE}/swap?fromTokenAddress=${fromAddr}&toTokenAddress=${toAddr}&amount=${parsedAmount}&fromAddress=${userAddress}&slippage=${slippage}`;
        const sr = await fetch(swapUrl);
        const sJson = await sr.json();
        if (!sJson || !sJson.tx) {
            console.error('swap build failed', sJson);
            alert('Swap build failed (see console).');
            return;
        }

        // send swap tx
        const txObj = sJson.tx; // {to, data, value}
        const txResponse = await signer.sendTransaction(txObj);
        alert('Swap sent: ' + txResponse.hash);
        console.log('swap tx', txResponse);

    } catch (e) {
        console.error('swap flow error', e);
        alert('Swap failed: ' + (e.message || e));
    }
}

$('swapBtn').addEventListener('click', ensureApprovalAndSwap);

/* ========= Small helpers: when selecting unknown address in global search, fill toToken and decimals ========= */
async function setToTokenFromAddress(addr){
    const low = lower(addr);
    let info = tokenMap.get(low);
    if (!info) {
        info = await fetchOnchainTokenInfo(addr);
        if (info) tokenMap.set(info.address, info);
    }
    if (info) {
        $('toToken').value = info.symbol || info.name;
        $('toToken').dataset.address = info.address;
        $('toToken').dataset.decimals = info.decimals || 18;
        updateQuoteDebounced();
    } else {
        // fallback: set raw address
        $('toToken').value = addr;
        $('toToken').dataset.address = low;
        $('toToken').dataset.decimals = 18;
    }
}

/* When page loads, wire up quick behaviors: when user pastes an address directly into from/to fields */
document.querySelectorAll('.input-box input[type="text"]').forEach(inp => {
    inp.addEventListener('paste', (ev) => {
        const text = (ev.clipboardData || window.clipboardData).getData('text').trim();
        if (isAddress(text)) {
            setTimeout(()=> {
                // fill dataset.address and fetch decimals
                const el = ev.target;
                el.dataset.address = lower(text);
                fetchOnchainTokenInfo(text).then(info => {
                    if (info) {
                        el.dataset.decimals = info.decimals || 18;
                        el.value = info.symbol || info.name;
                        tokenMap.set(info.address, info);
                        updateQuoteDebounced();
                    }
                });
            }, 10);
        }
    });
});

/* When global search submit (enter) attempt to fill To */
globalSearch.addEventListener('keydown', (e)=> {
    if (e.key === 'Enter') {
        const v = globalSearch.value.trim();
        if (isAddress(v)) setToTokenFromAddress(v);
        else {
            // try to find first matching token by symbol/name
            const found = tokenList.find(t => t.symbol.toLowerCase().includes(v.toLowerCase()) || t.name.toLowerCase().includes(v.toLowerCase()));
            if (found) {
                $('toToken').value = found.symbol;
                $('toToken').dataset.address = found.address;
                $('toToken').dataset.decimals = found.decimals || 18;
                updateQuoteDebounced();
            }
        }
        globalBox.style.display='none';
    }
});

/* Ensure globalBox reposition on resize */
window.addEventListener('resize', ()=> {
    globalBox.style.width = (globalSearch.offsetWidth) + 'px';
    globalBox.style.left = (globalSearch.offsetLeft) + 'px';
});

/* Add a small warm-up load of MATIC price and token list already done in loadTokensAndVolumes */
</script>
</body>
</html>
