<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NOLA DEX Aggregator — Price Layer</title>
<style>
  /* minimal styles copied to match original look & keep layout unchanged as much as possible */
  body { font-family: Inter, system-ui, Arial, sans-serif; background: #0b0b0c; color: #fff; margin: 0; padding: 22px; }
  h2 { margin: 0 0 14px 0; font-weight: 600; }
  .row { display:flex; gap:8px; align-items:center; margin-bottom:6px; }
  .input-box { background:#0f1720; border:1px solid rgba(255,255,255,0.06); color:#fff; padding:10px; border-radius:10px; width:140px; font-size:16px; }
  .token-btn { display:flex; align-items:center; gap:8px; padding:8px 10px; background:#0f1720; border-radius:10px; cursor:pointer; border:1px solid rgba(255,255,255,0.05); min-width:120px; }
  .token-btn img { width:22px; height:22px; border-radius:50%; object-fit:cover; }
  #fromUsd, #toUsd { color:#9aa0a6; font-size:14px; display:inline-flex; align-items:center; gap:8px; min-width:120px; }
  .usd-spinner { width:14px; height:14px; display:inline-block; border-radius:50%; border:2px solid rgba(255,255,255,0.12); border-top-color:#fff; animation:spin 1s linear infinite; visibility:hidden; }
  .usd-spinner.visible { visibility:visible; }
  @keyframes spin { to { transform: rotate(360deg); } }
  .small { font-size:13px; color:#aab0b6; }
  .center-bottom { position:fixed; left:50%; transform:translateX(-50%); bottom:12px; color:#9aa0a6; font-size:13px; }
  .swap-btn { padding:6px 10px; border-radius:8px; cursor:pointer; background:#111827; border:1px solid rgba(255,255,255,0.03); color:#fff;}
  /* keep UI intact */
</style>
</head>
<body>

  <h2>NOLA DEX Aggregator</h2>

  <!-- FROM -->
  <div class="row" style="margin-bottom:4px;">
    <input id="fromAmount" class="input-box" placeholder="0.0" />
    <div id="fromTokenBtn" class="token-btn" title="Select token (From)">
      <img id="fromIcon" src="" alt="">
      <span id="fromSymbol">Select</span>
    </div>
    <button id="swapBtn" class="swap-btn" title="Swap From/To">⇄</button>
  </div>
  <div id="fromUsd" class="small">
    <div class="usd-spinner" id="fromSpinner"></div>
    <span id="fromUsdText">$0.00</span>
  </div>

  <hr style="opacity:0.06; margin:12px 0;">

  <!-- TO -->
  <div class="row" style="margin-bottom:4px;">
    <input id="toAmount" class="input-box" placeholder="0.0" />
    <div id="toTokenBtn" class="token-btn" title="Select token (To)">
      <img id="toIcon" src="" alt="">
      <span id="toSymbol">Select</span>
    </div>
  </div>
  <div id="toUsd" class="small">
    <div class="usd-spinner" id="toSpinner"></div>
    <span id="toUsdText">$0.00</span>
  </div>

  <div style="height:18px;"></div>
  <div class="center-bottom">NOLA DEX — price layer active</div>

<script>
/*
  Price resolution logic:
    - Sources (priority): 1inch quote, CoinGecko (contract), Dexscreener, Firebird
    - Each source gets a 3000ms timeout; whichever returns first with a valid numeric USD price wins.
    - After user selects a token, price polling runs every 8 seconds.
*/

/* === CONFIG / helpers === */
const CHAIN = {
  ethereum: { id: 1, name: 'ethereum', usdc: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eb48' },
  polygon:  { id: 137, name: 'polygon',  usdc: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174' }
};
/* default chain for this demo */
let currentChain = CHAIN.polygon; // change to CHAIN.ethereum if needed

/* Small utility: timeout wrapper using AbortController */
function fetchWithTimeout(url, opts = {}, ms = 3000) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), ms);
  const init = Object.assign({}, opts, { signal: controller.signal });
  return fetch(url, init).finally(() => clearTimeout(id));
}

/* parse big integer price returned by some APIs into numeric USD using decimals */
function toNumberFromDecimals(amountStr, decimals = 18) {
  try {
    const Big = amountStr.toString();
    // simple conversion: amount / 10^decimals -> JS Number (could be imprecise but fine for UI)
    const a = BigInt(Big);
    const denom = 10n ** BigInt(decimals);
    const whole = a / denom;
    const rem = a % denom;
    const frac = Number(rem) / Number(denom);
    return Number(whole) + frac;
  } catch (e) {
    return null;
  }
}

/* show spinner */
function showSpinner(which, show = true) {
  const el = document.getElementById(which === 'from' ? 'fromSpinner' : 'toSpinner');
  if (el) el.classList.toggle('visible', show);
}

/* format currency */
function formatUSD(n) {
  if (!isFinite(n) || n === null) return '$0.00';
  if (n >= 1) return '$' + n.toLocaleString(undefined, { maximumFractionDigits: 2 });
  return '$' + n.toFixed(6).replace(/0+$/,'').replace(/\.$/,'');
}

/* === Token model (simple) ===
   For this single-file example the user can set tokens by clicking the token buttons
   I provide a tiny selection list popup (kept minimal so UI stays unchanged)
*/
const TOKENS_SAMPLE = [
  { chain: 'polygon', symbol: 'MATIC', address: '0x0000000000000000000000000000000000001010', decimals: 18, icon: '' },
  { chain: 'polygon', symbol: 'USDC', address: CHAIN.polygon.usdc, decimals: 6, icon: '' },
  { chain: 'polygon', symbol: 'WETH', address: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', decimals: 18, icon: '' },
  { chain: 'ethereum', symbol: 'USDC', address: CHAIN.ethereum.usdc, decimals: 6, icon: '' },
  { chain: 'ethereum', symbol: 'WETH', address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', decimals: 18, icon: '' }
];

let SELECTED = {
  from: null, // {chain, symbol, address, decimals}
  to: null
};

function setSelected(side, token) {
  SELECTED[side] = token;
  document.getElementById(side + 'Symbol').textContent = token.symbol || 'Unknown';
  const iconEl = document.getElementById(side + 'Icon');
  if (token.icon) iconEl.src = token.icon; else iconEl.src = '';
  // when token changes, start live updates for its USD price
  startLiveUpdates();
}

/* tiny on-page token picker (kept minimal so it doesn't alter layout) */
function showTokenPicker(side) {
  const list = TOKENS_SAMPLE.filter(t => t.chain === currentChain.name);
  const html = list.map((t, idx) => `<div data-idx="${idx}" style="padding:8px;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.03)">${t.symbol} — ${t.address}</div>`).join('');
  const win = window.open('', 'token-picker', 'width=420,height=360');
  if (!win) {
    alert('Popup blocked; please enable popups for this page.');
    return;
  }
  win.document.write(`<body style="background:#0b0b0c;color:#fff;font-family:Arial;padding:12px"><h3>Select token (${side})</h3><div id="list">${html}</div>
    <script>
      const divs = document.querySelectorAll('[data-idx]');
      divs.forEach(d=>d.addEventListener('click', ()=> {
        const idx = d.getAttribute('data-idx');
        const tok = ${JSON.stringify(list)}[idx];
        window.opener.postMessage({ action: 'tokenSelect', side: '${side}', token: tok }, '*');
        window.close();
      }));
    <\/script></body>`);
}

/* receive token selection from popup */
window.addEventListener('message', (ev) => {
  try {
    const data = ev.data;
    if (data && data.action === 'tokenSelect') {
      setSelected(data.side, data.token);
    }
  } catch(e){}
});

/* wire up token buttons */
document.getElementById('fromTokenBtn').addEventListener('click', () => showTokenPicker('from'));
document.getElementById('toTokenBtn').addEventListener('click', () => showTokenPicker('to'));
document.getElementById('swapBtn').addEventListener('click', () => {
  const a = SELECTED.from;
  const b = SELECTED.to;
  SELECTED.from = b; SELECTED.to = a;
  if (a) { document.getElementById('toSymbol').textContent = a.symbol; document.getElementById('toIcon').src = a.icon || ''; }
  if (b) { document.getElementById('fromSymbol').textContent = b.symbol; document.getElementById('fromIcon').src = b.icon || ''; }
  startLiveUpdates();
});

/* === Price Sources === */

/* 1) 1inch quote — uses 1inch public quote endpoint
   We'll request a quote swapping 1 unit (1e18) of token to USDC on the same chain.
   If token is native (like MATIC on Polygon) 1inch uses address 0xEeeee...; in sample we used MATIC pseudo-address
*/
async function fetchPriceFrom1Inch(tokenAddress, chainObj) {
  try {
    const chainId = chainObj.id;
    const toAddr = chainObj.usdc;
    // amount: use 1 * 10^decimals (we don't always know decimals); try 1e18 as default
    const amount = '1000000000000000000'; // 1e18
    const url = `https://api.1inch.io/v5.0/${chainId}/quote?fromTokenAddress=${tokenAddress}&toTokenAddress=${toAddr}&amount=${amount}`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('1inch non-ok');
    const j = await res.json();
    // j.toTokenAmount is amount of USDC (with toToken.decimals)
    if (!j.toTokenAmount || !j.toToken) throw new Error('1inch payload missing');
    const decimals = j.toToken.decimals ?? 6;
    const out = toNumberFromDecimals(j.toTokenAmount, decimals);
    // since amount represented 1e18 units of token, we compute price for 1 token in USD:
    // out is USDC amount for 1e18 base units -> price = out * (10^(18 - tokenDecimals)) but we don't know token decimals
    // 1inch response includes fromToken.decimals
    const fromDecimals = j.fromToken?.decimals ?? 18;
    // out is USDC for "amount" base units; so price_per_token = out / (amount / 10^fromDecimals)
    const amountUsed = BigInt(amount);
    const pricePerToken = out / Number(amountUsed) * Math.pow(10, fromDecimals);
    // Simplify: when we used amount=1e18 and fromDecimals=18, pricePerToken == out
    return Number(pricePerToken);
  } catch (e) {
    // console.warn('1inch failed', e);
    throw e;
  }
}

/* 2) CoinGecko contract lookup (if listed)
   - Endpoint: /api/v3/coins/{platform}/contract/{contract_address}
   - We'll try platform 'polygon-pos' for polygon, 'ethereum' for ethereum
*/
async function fetchPriceFromCoingecko(tokenAddress, chainObj) {
  try {
    const platform = (chainObj.id === 137) ? 'polygon-pos' : 'ethereum';
    const url = `https://api.coingecko.com/api/v3/coins/${platform}/contract/${tokenAddress}`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('coingecko not listed');
    const j = await res.json();
    const price = j?.market_data?.current_price?.usd;
    if (typeof price === 'number') return price;
    throw new Error('coingecko missing price');
  } catch (e) {
    // console.warn('coingecko fail', e);
    throw e;
  }
}

/* 3) Dexscreener pairs
   Dexscreener has pair endpoints that return USD price for pairs; we use their search-by-contract endpoint.
   Example: https://api.dexscreener.com/latest/dex/tokens/{contractAddress}
   (Note: Dexscreener may respond with multiple pairs — we pick the first pair with a USD price)
*/
async function fetchPriceFromDexscreener(tokenAddress, chainObj) {
  try {
    // Dexscreener token endpoint:
    const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('dexscreener fail');
    const j = await res.json();
    // j.pairs is array; each pair has priceUsd or priceUsd
    const pairs = j?.pairs || [];
    for (const p of pairs) {
      if (p?.priceUsd) return Number(p.priceUsd);
      if (p?.price) return Number(p.price); // fallback
    }
    throw new Error('dexscreener no price');
  } catch (e) {
    // console.warn('dexscreener fail', e);
    throw e;
  }
}

/* 4) Firebird aggregator (public aggregator endpoint)
   Firebird public APIs can vary; we'll attempt a known public endpoint pattern. If not available, this will error fast.
   For demo purposes this function tries a candidate endpoint and will throw if not usable.
*/
async function fetchPriceFromFirebird(tokenAddress, chainObj) {
  try {
    // Firebird aggregator has endpoints per chain on some deployments. We'll try a generic endpoint.
    // NOTE: This may fail due to availability or CORS; that's okay — it's a lower-priority fallback.
    const url = `https://api.firebird.finance/price?address=${tokenAddress}&chain=${chainObj.name}`;
    const res = await fetchWithTimeout(url, {}, 3000);
    if (!res.ok) throw new Error('firebird no');
    const j = await res.json();
    if (j && typeof j.price === 'number') return j.price;
    throw new Error('firebird missing price');
  } catch (e) {
    // console.warn('firebird fail', e);
    throw e;
  }
}

/* orchestrator: attempt sources in order with timeout protection and "race-like" semantics:
   - start each source in parallel (so fastest response wins) but we enforce each call has a 3s abort
   - we pick the first fulfilled promise that returns a finite number
*/
async function getTokenPriceUSD(tokenAddress, chainObj) {
  // normalize address lower
  const addr = (tokenAddress || '').toString();
  if (!addr) throw new Error('no address');

  const sources = [
    fetchPriceFrom1Inch,
    fetchPriceFromCoingecko,
    fetchPriceFromDexscreener,
    fetchPriceFromFirebird
  ];

  // prepare an array of wrapped promises with 3s behavior already inside each source
  const wrapped = sources.map(fn => {
    // call fn and if it resolves with number, return it; otherwise reject
    return new Promise(async (resolve, reject) => {
      try {
        const v = await fn(addr, chainObj);
        if (typeof v === 'number' && isFinite(v) && v > 0) resolve({ price: v, source: fn.name });
        else reject(new Error('invalid price'));
      } catch (e) {
        reject(e);
      }
    });
  });

  // run them in parallel and return first that fulfills
  return new Promise((resolve, reject) => {
    let settled = false;
    let pending = wrapped.length;
    wrapped.forEach(p => {
      p.then(res => {
        if (!settled) {
          settled = true;
          resolve(res);
        }
      }).catch(_ => {
        pending--;
        if (pending === 0 && !settled) {
          reject(new Error('all sources failed'));
        }
      });
    });
    // absolute safety timeout (4s) in case all calls hang in some weird way
    setTimeout(() => {
      if (!settled) {
        reject(new Error('timeout-all'));
      }
    }, 4000);
  });
}

/* === Live update logic === */
let liveInterval = null;
let lastFromAddr = null;
let lastToAddr = null;

function startLiveUpdates() {
  // stop existing
  if (liveInterval) clearInterval(liveInterval);
  // run initial immediate fetch for selected tokens
  updateAllPrices();
  // then every 8s
  liveInterval = setInterval(updateAllPrices, 8000);
}

async function updateAllPrices() {
  // update FROM USD
  if (SELECTED.from && SELECTED.from.address) {
    const addr = SELECTED.from.address;
    lastFromAddr = addr;
    showSpinner('from', true);
    try {
      const { price, source } = await getTokenPriceUSD(addr, currentChain);
      // price is USD per token
      if (lastFromAddr === addr) { // ensure no race
        document.getElementById('fromUsdText').textContent = formatUSD(price);
        // optionally you can also compute the conversion for fromAmount input
        const amt = parseFloat(document.getElementById('fromAmount').value || '0');
        if (amt) {
          document.getElementById('fromUsdText').textContent = formatUSD(price * amt);
        }
      }
    } catch (e) {
      // on error keep previous value
      console.warn('FROM price failed', e);
    } finally {
      showSpinner('from', false);
    }
  }
  // update TO USD
  if (SELECTED.to && SELECTED.to.address) {
    const addr = SELECTED.to.address;
    lastToAddr = addr;
    showSpinner('to', true);
    try {
      const { price, source } = await getTokenPriceUSD(addr, currentChain);
      if (lastToAddr === addr) {
        document.getElementById('toUsdText').textContent = formatUSD(price);
        const amt = parseFloat(document.getElementById('toAmount').value || '0');
        if (amt) {
          document.getElementById('toUsdText').textContent = formatUSD(price * amt);
        }
      }
    } catch (e) {
      console.warn('TO price failed', e);
    } finally {
      showSpinner('to', false);
    }
  }
}

/* update USD when user types amount */
document.getElementById('fromAmount').addEventListener('input', () => {
  const amt = parseFloat(document.getElementById('fromAmount').value || '0');
  // if we have last known FROM price text like $X, we can recompute:
  // We don't keep numeric price; easiest is run one-shot price fetch now (but we prefer to avoid extra calls).
  // For simplicity, trigger immediate updateAllPrices (it will show spinner and fetch).
  updateAllPrices();
});
document.getElementById('toAmount').addEventListener('input', () => {
  updateAllPrices();
});

/* initial sample: set default tokens to show behavior without touching UI */
(function init() {
  // set default tokens from the sample that match current chain
  const sampleFrom = TOKENS_SAMPLE.find(t => t.chain === currentChain.name && t.symbol === 'MATIC') || TOKENS_SAMPLE.find(t => t.chain === currentChain.name);
  const sampleTo = TOKENS_SAMPLE.find(t => t.chain === currentChain.name && t.symbol === 'USDC') || null;
  if (sampleFrom) setSelected('from', sampleFrom);
  if (sampleTo) setSelected('to', sampleTo);
  // start the live updates loop
  startLiveUpdates();
})();

/* Note:
   - If you deploy and see CORS errors, you can proxy these API calls through your backend or a simple CORS proxy.
   - 1inch / CoinGecko / Dexscreener are public endpoints but may enforce rate limits.
   - Firebird endpoint used is a best-effort placeholder; if you use a specific Firebird deployment, replace the URL in fetchPriceFromFirebird.
*/
</script>

</body>
</html>
